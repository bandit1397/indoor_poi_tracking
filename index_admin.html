<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>🏬 다층 백화점 길안내 (층간 이동 자동 연결) - Admin Download</title>
<style>
  body { margin:0; overflow:hidden; font-family:sans-serif; }
  canvas { border:1px solid #ccc; display:block; cursor:crosshair; }
  #controls {
    position: fixed; top:10px; left:10px;
    background: rgba(255,255,255,0.95); padding:10px; border-radius:6px; z-index:10;
  }
  select, button, input { margin:2px; }
  #infoBox {
    position: absolute;
    background: rgba(0,0,0,0.7); color:#fff; padding:5px 10px; border-radius:6px; font-weight:bold;
    display:none; pointer-events:none; white-space: nowrap;
  }
  #nodeDialog {
    display:none; position:fixed; top:50%; left:50%;
    transform:translate(-50%,-50%);
    background:#fff; border:1px solid #ccc; padding:15px;
    border-radius:8px; z-index:1000; box-shadow:0 4px 12px rgba(0,0,0,0.2);
  }
  #nodeDialog h3 { margin:0 0 8px 0; font-size:16px; }
  #nodeDialog .typeBtn { margin:2px; padding:3px 6px; cursor:pointer; }
  #searchResults {
    position:absolute; background:#fff; border:1px solid #ccc;
    display:none; z-index:10; max-height:200px; overflow-y:auto;
  }
  #searchResults div:hover { background:#eef; }
  /* 관리자 버튼 작게 그룹화 */
  #adminControls { margin-top:6px; border-top:1px dashed #ddd; padding-top:6px; }
  #adminControls button { font-size:12px; }
</style>
</head>
<body>

<div id="controls">
  <div>
    Floor plan 업로드: <input type="file" id="fileInput" accept="image/*">
  </div>
  <div>
    출발지: <select id="start"></select>
    목적지: <select id="end"></select>
    <button onclick="findPath()">길찾기</button>
    <button onclick="resetAll()">초기화</button>
  </div>
  <div style="position:relative;">
    위치 검색: <input type="text" id="searchInput" autocomplete="off">
    <button onclick="manualSearch()">검색</button>
    <button id="addNodeBtn">노드추가</button>
    <div id="searchResults"></div>
  </div>

  <!-- 관리자용 다운로드 버튼 (비밀번호 보호) -->
  <div id="adminControls">
    <strong>관리자</strong>:
    <button onclick="adminDownloadFloorplan()">floorplan.png 다운로드</button>
    <button onclick="adminDownloadLocations()">locations.json 다운로드</button>
    <button onclick="adminUploadLocations()">locations.json 불러오기</button>
    <input type="file" id="locationsImportInput" accept="application/json" style="display:none">
  </div>
</div>

<div id="infoBox"></div>
<canvas id="map"></canvas>

<div id="nodeDialog">
  <h3>새 노드 추가</h3>
  <div>
    <label><input type="radio" name="floorType" value="지상" checked> 지상</label>
    <label><input type="radio" name="floorType" value="지하"> 지하</label>
    <input type="number" id="floorNumber" min="1" value="1" style="width:60px"> 층
  </div>
  <div style="margin-top:8px;">
    <label>노드 이름: <input type="text" id="nodeName" placeholder="예: 1번 계단 / 에스1 / 엘리1"></label>
  </div>
  <div style="margin-top:8px;">
    <span>노드 타입:</span><br>
    <button type="button" class="typeBtn" data-type="normal">normal</button>
    <button type="button" class="typeBtn" data-type="elevator">elevator</button>
    <button type="button" class="typeBtn" data-type="stairs">stairs</button>
    <button type="button" class="typeBtn" data-type="escalator">escalator</button>
  </div>
  <div style="margin-top:8px;">
    <label>참고사항: <input type="text" id="nodeNote"></label>
  </div>
  <div style="margin-top:10px; text-align:right;">
    <button onclick="closeNodeDialog()">취소</button>
    <button onclick="saveNode()">저장</button>
  </div>
</div>

<script>
/** ===== 전역 상태 ===== */
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');
const fileInput = document.getElementById('fileInput');
const searchInput = document.getElementById('searchInput');
const infoBox = document.getElementById('infoBox');
const startSel = document.getElementById('start');
const endSel = document.getElementById('end');
const addNodeBtn = document.getElementById('addNodeBtn');
const searchResults = document.getElementById('searchResults');
const locationsImportInput = document.getElementById('locationsImportInput');

let floorImg = null;
let floorImgDataURL = null; // <-- 업로드한 원본 이미지 DataURL 저장
let nodes = {};
let edges = {};
let nodeNames = [];
let blinkNode = null;
let blinkInterval = null;
let pathNodes = [];
let selectingMode = null;
let addingNodeMode = false;
let tempX=0, tempY=0, selectedType='normal';
let password = 'knp123';

/* 캔버스 리사이즈 및 드로우 */
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
}
window.addEventListener('resize', resizeCanvas);

/* floor image 업로드 처리 (원본 DataURL 저장) */
fileInput.addEventListener('change',(e)=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    floorImgDataURL = evt.target.result; // 원본 DataURL 저장 (다운로드용)
    const img = new Image();
    img.onload = ()=>{ 
      floorImg = img; 
      resetAll(true);
      resizeCanvas();
    };
    img.src = floorImgDataURL;
  };
  reader.readAsDataURL(file);
});

/* 기존 getLabel 함수 */
function getLabel(fullName){ 
  const s = fullName.split(' ');
  return s.length > 1 ? s.slice(1).join(' ').trim() : fullName;
}

/** ===== 출발/목적지 선택 모드 ===== */
startSel.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); enterSelectingMode('start'); startSel.blur(); });
endSel.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); enterSelectingMode('end'); endSel.blur(); });
function enterSelectingMode(mode){ selectingMode = mode; showInfo((mode==='start'?'출발':'목적지')+' 노드를 선택하세요.', 0); }

/** ===== 노드추가 버튼 클릭 ===== */
addNodeBtn.addEventListener('click',()=>{
  const inputPwd = prompt("노드추가 비밀번호를 입력하세요:");
  if(inputPwd === password){
    showInfo('캔버스에서 노드를 추가할 위치를 클릭하세요.', 2000);
    addingNodeMode = true;
  } else {
    alert("비밀번호 틀림. 노드추가 취소.");
  }
});

/* 정보박스 표시 */
let infoTimeout = null;
function showInfo(text, ms=2000, x=null, y=null){
  if(infoTimeout){ clearTimeout(infoTimeout); infoTimeout=null; }
  infoBox.style.display='block';
  infoBox.textContent = text;
  if(x!==null && y!==null){
    infoBox.style.left = (x+10) + 'px';
    infoBox.style.top = (y-30) + 'px';
  } else {
    infoBox.style.left = '10px';
    infoBox.style.top = (window.innerHeight-40)+'px';
  }
  if(ms>0){
    infoTimeout = setTimeout(()=>{ infoBox.style.display='none'; infoTimeout=null; }, ms);
  }
}

/** ===== 마우스 인터랙션 ===== */
let lastClickTime = 0;
canvas.addEventListener('click',(e)=>{
  if(!floorImg) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const clickedNode = findNodeAt(x,y);

  if(selectingMode){
    if(clickedNode){
      if(selectingMode === 'start'){
        startSel.innerHTML = ''; 
        const opt = document.createElement('option'); opt.value=clickedNode; opt.textContent=getLabel(clickedNode); startSel.appendChild(opt);
        startSel.value = clickedNode;
      } else if(selectingMode === 'end'){
        endSel.innerHTML = '';
        const opt = document.createElement('option'); opt.value=clickedNode; opt.textContent=getLabel(clickedNode); endSel.appendChild(opt);
        endSel.value = clickedNode;
      }
      selectingMode = null;
      showInfo('선택 완료: ' + clickedNode, 1200);
      draw();
      return;
    } else {
      showInfo('노드를 클릭하여 선택하세요.', 1200);
      return;
    }
  }

  if(addingNodeMode){
    tempX = x; tempY = y;
    openNodeDialog(x,y);
    addingNodeMode = false;
    return;
  }

  if(clickedNode){
    const now = Date.now();
    if(now - lastClickTime < 300){
      const inputPwd = prompt("노드 삭제 비밀번호를 입력하세요:");
      if(inputPwd === password){
        delete nodes[clickedNode];
        nodeNames = nodeNames.filter(nm=>nm!==clickedNode);
        delete edges[clickedNode];
        for(let key in edges) edges[key]=edges[key].filter(nm=>nm!==clickedNode);
        pathNodes=[];
        showInfo('노드 삭제 완료',1200,x,y);
        draw();
      } else {
        alert("비밀번호 틀림. 삭제 취소.");
      }
    } else {
      const n = nodes[clickedNode];
      showInfo(`${getLabel(clickedNode)} : ${n.note||'참고사항 없음'}`, 2000, x, y);
    }
    lastClickTime = now;
    return;
  }
});

function findNodeAt(x,y){
  for(let name of nodeNames){
    const node = nodes[name];
    if(Math.hypot(node.x-x,node.y-y)<=8) return name;
  }
  return null;
}

/** ===== 최단경로: Dijkstra ===== */
function distance(n1,n2){ return Math.hypot(n1.x-n2.x,n1.y-n2.y); }
function dijkstra(start,end,allowedNodes=null){
  const visited=new Set(), distances={}, prev={};
  const targetNodes = allowedNodes||nodeNames;
  targetNodes.forEach(n=>{ distances[n]=Infinity; });
  distances[start]=0;

  while(visited.size<targetNodes.length){
    let minNode=null;
    for(let n of targetNodes){
      if(!visited.has(n)&&(minNode===null||distances[n]<distances[minNode])) minNode=n;
    }
    if(minNode===null) break;
    if(minNode===end) break;
    visited.add(minNode);

    const adj = edges[minNode]||[];
    for(let nb of adj){
      if(!targetNodes.includes(nb)) continue;
      let alt = distances[minNode]+distance(nodes[minNode],nodes[nb]);
      if(alt<distances[nb]) { distances[nb]=alt; prev[nb]=minNode; }
    }
  }

  const path=[]; let curr=end;
  while(curr){ path.unshift(curr); curr=prev[curr]; }
  if(path[0]!==start) return []; 
  return path;
}

function multiFloorPath(startName,endName){ return dijkstra(startName,endName); }
function findPath(){
  const s = startSel.value; const e = endSel.value;
  if(!s || !e){ alert('출발지/목적지를 선택하세요.'); return; }
  pathNodes = multiFloorPath(s,e) || [];
  if(pathNodes.length===0) alert('경로를 찾을 수 없습니다.');
  draw();
}

/** ===== 검색 기능: 노드 이름/타입/참고사항 통합 ===== */
function normalize(str){
  return str.replace(/\s+/g,'').replace(/[^\w가-힣]/g,'').toLowerCase();
}

function searchNodes(query){
  const q = normalize(query);
  if(q.length<2) return [];
  const results=[];
  for(let name of nodeNames){
    const node = nodes[name];
    const fields = [name, node.type, node.note||''];
    for(let f of fields){
      if(normalize(f).includes(q)){
        results.push({fullName:name, display:`${getLabel(name)} [${node.type}] ${node.note||''}`});
        break;
      }
    }
  }
  return results;
}

searchInput.addEventListener('input', ()=>{
  const query = searchInput.value;
  const results = searchNodes(query);
  searchResults.innerHTML='';
  if(results.length>0){
    searchResults.style.display='block';
    results.forEach(r=>{
      const div = document.createElement('div');
      div.textContent = r.display;
      div.style.padding='2px 5px';
      div.style.cursor='pointer';
      div.addEventListener('click', ()=>{
        searchInput.value = getLabel(r.fullName);
        searchResults.style.display='none';
        highlightNode(r.fullName);
      });
      searchResults.appendChild(div);
    });
  } else {
    searchResults.style.display='none';
  }
});

function manualSearch(){
  const val = searchInput.value.trim();
  if(!val){ alert('검색어 입력'); return; }
  const results = searchNodes(val);
  if(results.length>0) highlightNode(results[0].fullName);
  else alert('노드 없음');
}

/** ===== 노드 강조(blink) ===== */
function highlightNode(name=null){
  const nodeToBlink = name||nodeNames.find(n=>getLabel(n)===searchInput.value);
  if(!nodeToBlink){ alert("노드 없음"); return; }

  if(blinkInterval) clearInterval(blinkInterval);
  blinkNode = nodeToBlink;

  let opacity = 0.2;
  let growing = true;

  blinkInterval=setInterval(()=>{
    if(growing){ opacity += 0.1; if(opacity >= 0.8) growing = false; } 
    else { opacity -= 0.1; if(opacity <= 0.2) growing = true; }
    draw(opacity);
  },100);

  setTimeout(()=>{ clearInterval(blinkInterval); blinkInterval=null; blinkNode=null; draw(); },3000);
}

/** ===== 초기화 ===== */
function resetAll(skipConfirm=false){
  if(!skipConfirm && !confirm("경로를 초기화하시겠습니까?")) return;
  pathNodes=[];
  if(blinkInterval){ clearInterval(blinkInterval); blinkInterval=null; }
  blinkNode=null;
  selectingMode = null;
  addingNodeMode = false;
  if(infoTimeout){ clearTimeout(infoTimeout); infoTimeout=null; }
  infoBox.style.display='none';
  startSel.innerHTML=''; endSel.innerHTML='';
  searchResults.style.display='none';
  draw();
}

/** ===== 노드 다이얼로그 ===== */
function openNodeDialog(x,y){ document.getElementById('nodeDialog').style.display='block'; }
function closeNodeDialog(){ document.getElementById('nodeDialog').style.display='none'; }
document.querySelectorAll('#nodeDialog .typeBtn').forEach(btn=>btn.addEventListener('click',()=>{ selectedType=btn.dataset.type; }));

function addEdge(a,b){
  edges[a]=edges[a]||[]; edges[b]=edges[b]||[];
  if(!edges[a].includes(b)) edges[a].push(b);
  if(!edges[b].includes(a)) edges[b].push(a);
}

function saveNode(){
  const name=document.getElementById('nodeName').value.trim();
  const floor=document.querySelector('input[name="floorType"]:checked').value+document.getElementById('floorNumber').value+'층';
  const note=document.getElementById('nodeNote').value;
  if(!name){ alert("노드 이름 입력"); return; }
  const fullName=`${floor} ${name}`;
  if(nodes[fullName]){ alert("이미 존재"); return; }

  nodes[fullName]={x:tempX,y:tempY,floor,type:selectedType,note};
  nodeNames.push(fullName);

  nodeNames.forEach(n=>{
    if(n!==fullName && nodes[n].floor===floor){ addEdge(n, fullName); }
  });

  if(selectedType==='escalator' || selectedType==='stairs' || selectedType==='elevator'){
    for(let n of nodeNames){
      if(n===fullName) continue;
      if(nodes[n].type===selectedType && getLabel(n)===getLabel(fullName)){
        addEdge(n, fullName);
      }
    }
  }

  // 선택 목록 자동 갱신: (기존 기능 유지)
  updateStartEndOptions();

  closeNodeDialog(); draw();
}

/* start/end select를 nodes 변화에 맞춰 갱신하는 헬퍼 */
function updateStartEndOptions(){
  // 기존 선택값 유지시키려면 더 복잡해지지만, 간단히 비워두고 사용자가 재선택하도록.
  // (기존 UX와 충돌하지 않도록 minimal)
  startSel.innerHTML=''; endSel.innerHTML='';
}

/** ===== 그리기 ===== */
function draw(opacity=1){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(floorImg) ctx.drawImage(floorImg,0,0,canvas.width,canvas.height);

  if(pathNodes.length>1){
    ctx.strokeStyle='red'; ctx.lineWidth=4;
    ctx.beginPath();
    pathNodes.forEach((n,i)=>{
      const node=nodes[n];
      if(i===0) ctx.moveTo(node.x,node.y);
      else ctx.lineTo(node.x,node.y);
    });
    ctx.stroke();
  }

  nodeNames.forEach(n=>{
    const node=nodes[n];
    let radius = 8;
    if(n===blinkNode) radius = 14;
    ctx.beginPath();
    ctx.arc(node.x,node.y,radius,0,Math.PI*2);
    if(n===blinkNode){ ctx.fillStyle=`rgba(255,255,0,${opacity})`; } 
    else if(pathNodes.includes(n)){ ctx.fillStyle='red'; } 
    else { ctx.fillStyle=node.type==='normal'?'blue':(node.type==='stairs'?'orange':node.type==='elevator'?'green':'purple'); }
    ctx.fill(); ctx.strokeStyle='#000'; ctx.stroke();
  });
}

/** ===== 관리자 다운로드 기능 ===== */

/* 관리자 인증 공통 */
function requestAdminPassword(){
  return prompt("관리자 비밀번호를 입력하세요:") || '';
}

/* floorplan.png 다운로드 (원본 업로드 이미지를 그대로 내보냄) */
function adminDownloadFloorplan(){
  if(!floorImgDataURL){ alert('업로드된 floorplan 이미지가 없습니다.'); return; }
  const inputPwd = requestAdminPassword();
  if(inputPwd !== password){ alert('비밀번호 틀림. 다운로드 취소.'); return; }
  // DataURL 그대로 다운로드 (PNG)
  const a = document.createElement('a');
  a.href = floorImgDataURL;
  a.download = 'floorplan.png';
  document.body.appendChild(a);
  a.click();
  a.remove();
}

/* locations.json 다운로드 (nodes, edges, nodeNames, canvas 크기 포함) */
function adminDownloadLocations(){
  const inputPwd = requestAdminPassword();
  if(inputPwd !== password){ alert('비밀번호 틀림. 다운로드 취소.'); return; }
  const payload = {
    exportedAt: new Date().toISOString(),
    canvas: { width: canvas.width, height: canvas.height },
    nodes: nodes,
    edges: edges,
    nodeNames: nodeNames
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'locations.json';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/* locations.json 불러오기 (관리자 전용) - 기존 기능 유지하면서 노드/엣지 불러와 상태 갱신 */
function adminUploadLocations(){
  const inputPwd = requestAdminPassword();
  if(inputPwd !== password){ alert('비밀번호 틀림. 불러오기 취소.'); return; }
  locationsImportInput.click();
}

locationsImportInput.addEventListener('change', (e)=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    try{
      const data = JSON.parse(evt.target.result);
      if(data.nodes && data.edges && data.nodeNames){
        // 덮어쓰기 전에 간단한 확인
        if(!confirm("현재 메모리에 있는 노드/엣지를 덮어쓰시겠습니까?")) return;
        nodes = data.nodes;
        edges = data.edges;
        nodeNames = data.nodeNames;
        // 캔버스 크기 정보가 있으면 알림만 (자동 변환은 하지 않음)
        if(data.canvas) showInfo(`불러옴: canvas(${data.canvas.width}x${data.canvas.height})`,3000);
        updateStartEndOptions();
        draw();
      } else {
        alert('유효한 locations.json 파일이 아닙니다.');
      }
    } catch(err){
      alert('파일 파싱 실패: ' + err.message);
    }
  };
  reader.readAsText(file);
  // 파일 input 초기화
  locationsImportInput.value = '';
});

/* 초기 렌더 */
resizeCanvas();

</script>
</body>
</html>
