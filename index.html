<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>ğŸ¬ ë‹¤ì¸µ ë°±í™”ì  ê¸¸ì•ˆë‚´ (ì¸µê°„ ì´ë™ ìë™ ì—°ê²°)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<style>
  :root { color-scheme: light dark; }
  * { box-sizing: border-box; }
  body { margin:0; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  canvas { border:1px solid #ccc; display:block; cursor:crosshair; }
  #controls {
    position: fixed; top:10px; left:10px;
    background: rgba(255,255,255,0.95); padding:10px; border-radius:10px; z-index:10;
    box-shadow: 0 4px 16px rgba(0,0,0,0.15); backdrop-filter: saturate(1.2) blur(4px);
    max-width: calc(100vw - 20px);
  }
  #controls .row { display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; align-items:center; }
  select, button, input { margin:0; padding:8px 10px; border-radius:8px; border:1px solid #ddd; font-size:14px; }
  button { background:#0ea5e9; color:white; border:none; cursor:pointer; }
  button.secondary { background:#64748b; }
  button.warn { background:#ef4444; }
  button:active { transform: translateY(1px); }
  #infoBox {
    position: absolute;
    background: rgba(0,0,0,0.7); color:#fff; padding:6px 10px; border-radius:8px; font-weight:600;
    display:none; pointer-events:none; white-space: nowrap; z-index: 9;
  }
  #nodeDialog {
    display:none; position:fixed; top:50%; left:50%;
    transform:translate(-50%,-50%);
    background:#fff; border:1px solid #e5e7eb; padding:16px;
    border-radius:12px; z-index:1000; box-shadow:0 12px 30px rgba(0,0,0,0.25); width:min(92vw,420px);
  }
  #nodeDialog h3 { margin:0 0 10px 0; font-size:18px; }
  #nodeDialog .typeBtn { margin:4px; padding:6px 10px; cursor:pointer; border:1px solid #ddd; border-radius:999px; background:#f8fafc; }
  #nodeDialog label { display:block; margin-top:8px; }
  #searchResults {
    position:absolute; background:#fff; border:1px solid #e5e7eb; border-radius:8px;
    display:none; z-index:10; max-height:220px; overflow-y:auto; min-width: 240px; box-shadow: 0 8px 24px rgba(0,0,0,0.12);
  }
  #searchResults div { padding:6px 8px; cursor:pointer; }
  #searchResults div:hover { background:#eef; }
  @media (max-width: 640px) {
    #controls { right:10px; left:10px; }
    select, input { min-width: 140px; }
  }
</style>
</head>
<body>

<div id="controls" role="region" aria-label="ê¸¸ì•ˆë‚´ ì»¨íŠ¸ë¡¤">
  <div class="row">
    <strong>ì¸µê°„ ê¸¸ì•ˆë‚´</strong>
    <button id="downloadBtn" class="secondary" title="í˜„ì¬ ë…¸ë“œ ë°ì´í„°ë¥¼ JSONìœ¼ë¡œ ì €ì¥">JSON ë‹¤ìš´ë¡œë“œ</button>
    <button id="resetBtn" class="warn" title="ê²½ë¡œ ë° ìƒíƒœ ì´ˆê¸°í™”">ì´ˆê¸°í™”</button>
  </div>
  <div class="row">
    ì¶œë°œì§€: <select id="start" title="ì¶œë°œì§€ ì„ íƒ(ìº”ë²„ìŠ¤ì—ì„œ ë…¸ë“œë¥¼ í´ë¦­í•´ë„ ë©ë‹ˆë‹¤)"></select>
    ëª©ì ì§€: <select id="end" title="ëª©ì ì§€ ì„ íƒ(ìº”ë²„ìŠ¤ì—ì„œ ë…¸ë“œë¥¼ í´ë¦­í•´ë„ ë©ë‹ˆë‹¤)"></select>
    <button id="routeBtn" title="ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°">ê¸¸ì°¾ê¸°</button>
  </div>
  <div class="row" style="position:relative;">
    ìœ„ì¹˜ ê²€ìƒ‰: <input type="text" id="searchInput" autocomplete="off" placeholder="ì˜ˆ: 1ë²ˆ ê³„ë‹¨ / í‘¸ë“œì½”íŠ¸">
    <button id="searchBtn">ê²€ìƒ‰</button>
    <button id="addNodeBtn">ë…¸ë“œì¶”ê°€</button>
    <div id="searchResults" role="listbox" aria-label="ê²€ìƒ‰ ê²°ê³¼"></div>
  </div>
</div>

<div id="infoBox"></div>
<canvas id="map" aria-label="ì¸µê°„ ì§€ë„ ìº”ë²„ìŠ¤"></canvas>

<!-- ë…¸ë“œ ì…ë ¥ ë‹¤ì´ì–¼ë¡œê·¸ -->
<div id="nodeDialog" role="dialog" aria-modal="true" aria-labelledby="nodeDialogTitle">
  <h3 id="nodeDialogTitle">ìƒˆ ë…¸ë“œ ì¶”ê°€</h3>
  <div>
    <label>
      <input type="radio" name="floorType" value="ì§€ìƒ" checked> ì§€ìƒ
    </label>
    <label>
      <input type="radio" name="floorType" value="ì§€í•˜"> ì§€í•˜
    </label>
    <input type="number" id="floorNumber" min="1" value="1" style="width:70px"> ì¸µ
  </div>
  <label>ë…¸ë“œ ì´ë¦„:
    <input type="text" id="nodeName" placeholder="ì˜ˆ: 1ë²ˆ ê³„ë‹¨ / ì—ìŠ¤1 / ì—˜ë¦¬1">
  </label>
  <div style="margin-top:8px;">
    <span>ë…¸ë“œ íƒ€ì…:</span><br>
    <button type="button" class="typeBtn" data-type="normal">normal</button>
    <button type="button" class="typeBtn" data-type="elevator">elevator</button>
    <button type="button" class="typeBtn" data-type="stairs">stairs</button>
    <button type="button" class="typeBtn" data-type="escalator">escalator</button>
  </div>
  <label>ì°¸ê³ ì‚¬í•­:
    <input type="text" id="nodeNote" placeholder="ì˜ˆ: ì¶œì…êµ¬/í™”ì¥ì‹¤ ë°©í–¥ ë“±">
  </label>
  <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
    <button id="cancelNodeBtn" class="secondary">ì·¨ì†Œ</button>
    <button id="saveNodeBtn">ì €ì¥</button>
  </div>
</div>

<script>
/** ===== ì „ì—­ ìƒíƒœ ===== */
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');

const searchInput = document.getElementById('searchInput');
const infoBox = document.getElementById('infoBox');
const startSel = document.getElementById('start');
const endSel = document.getElementById('end');
const addNodeBtn = document.getElementById('addNodeBtn');
const searchResults = document.getElementById('searchResults');
const routeBtn = document.getElementById('routeBtn');
const resetBtn = document.getElementById('resetBtn');
const downloadBtn = document.getElementById('downloadBtn');

let floorImg = null;
let nodes = {};      // { "ì§€ìƒ1ì¸µ A": {x,y,floor,type,note}, ... } x,y: 0~1 ìƒëŒ€ì¢Œí‘œ
let edges = {};      // { "ì§€ìƒ1ì¸µ A": ["ì§€ìƒ1ì¸µ B", ...], ... }
let nodeNames = [];  // ["ì§€ìƒ1ì¸µ A", "ì§€ìƒ1ì¸µ B", ...]
let blinkNode = null;
let blinkInterval = null;
let pathNodes = [];
let selectingMode = null;  // 'start' | 'end' | null
let addingNodeMode = false;
let tempX=0, tempY=0, selectedType='normal';
let password = 'knp123';   // ë…¸ë“œ ì¶”ê°€/ì‚­ì œ ë¹„ë°€ë²ˆí˜¸

/** ===== ë°˜ì‘í˜• ìº”ë²„ìŠ¤ ===== */
function resizeCanvas(){
  const vh = Math.max(window.innerHeight, document.documentElement.clientHeight || 0);
  const vw = Math.max(window.innerWidth, document.documentElement.clientWidth || 0);
  canvas.width = vw;
  canvas.height = vh;
  draw();
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 300));

/** ===== ì´ë¯¸ì§€/JSON ìë™ ë¡œë“œ ===== */
function loadFloorImage(){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => { floorImg = img; resolve(); };
    img.onerror = reject;
    img.src = 'floorplan.png';
  });
}

function loadLocations(){
  return fetch('locations.json', { cache: 'no-store' })
    .then(res => { if(!res.ok) throw new Error('locations.json ë¡œë“œ ì‹¤íŒ¨'); return res.json(); })
    .then(data => {
      nodes = data.nodes || {};
      edges = data.edges || {};
      nodeNames = data.nodeNames || Object.keys(nodes);
      nodeNames.forEach(n => { edges[n] = edges[n] || []; });
    })
    .catch(err => { console.warn(err); nodes={}; edges={}; nodeNames=[]; });
}

/** ===== ì´ˆê¸°í™” ì‹œí€€ìŠ¤ ===== */
(async function init(){
  await Promise.all([loadFloorImage(), loadLocations()]);
  bindUI();
  resizeCanvas();
  draw();
})();

/** ===== ë¼ë²¨ ë„ìš°ë¯¸ ===== */
function getLabel(fullName){ const s=fullName.split(' '); return s.length>1?s.slice(1).join(' ').trim():fullName; }

/** ===== UI ë°”ì¸ë”© ===== */
function bindUI(){
  startSel.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); enterSelectingMode('start'); startSel.blur(); });
  endSel.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); enterSelectingMode('end'); endSel.blur(); });

  routeBtn.addEventListener('click', findPath);
  resetBtn.addEventListener('click', ()=> resetAll(false));
  downloadBtn.addEventListener('click', downloadJSON);
  document.getElementById('searchBtn').addEventListener('click', manualSearch);

  canvas.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const x = t.clientX - rect.left;
    const y = t.clientY - rect.top;
    handleCanvasTap(x,y);
  }, {passive:true});

  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    handleCanvasTap(e.clientX - rect.left, e.clientY - rect.top);
  });

  addNodeBtn.addEventListener('click',()=>{
    const inputPwd = prompt("ë…¸ë“œì¶”ê°€ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
    if(inputPwd === password){
      showInfo('ìº”ë²„ìŠ¤ì—ì„œ ë…¸ë“œë¥¼ ì¶”ê°€í•  ìœ„ì¹˜ë¥¼ íƒ­/í´ë¦­í•˜ì„¸ìš”.', 2000);
      addingNodeMode = true;
    } else { alert("ë¹„ë°€ë²ˆí˜¸ í‹€ë¦¼. ë…¸ë“œì¶”ê°€ ì·¨ì†Œ."); }
  });

  searchInput.addEventListener('input', ()=>{
    const query = searchInput.value;
    const results = searchNodes(query);
    searchResults.innerHTML='';
    if(results.length>0){
      searchResults.style.display='block';
      results.forEach(r=>{
        const div = document.createElement('div');
        div.textContent = r.display;
        div.addEventListener('click', ()=>{ searchInput.value=getLabel(r.fullName); searchResults.style.display='none'; highlightNode(r.fullName); });
        searchResults.appendChild(div);
      });
    } else searchResults.style.display='none';
  });

  document.querySelectorAll('#nodeDialog .typeBtn').forEach(btn =>
    btn.addEventListener('click',()=>{ selectedType=btn.dataset.type; })
  );
  document.getElementById('cancelNodeBtn').addEventListener('click', closeNodeDialog);
  document.getElementById('saveNodeBtn').addEventListener('click', saveNode);
}

/** ===== ì •ë³´ í† ìŠ¤íŠ¸ ===== */
let infoTimeout = null;
function showInfo(text, ms=2000, x=null, y=null){
  if(infoTimeout){ clearTimeout(infoTimeout); infoTimeout=null; }
  infoBox.style.display='block';
  infoBox.textContent=text;
  if(x!==null && y!==null){ infoBox.style.left=(x+10)+'px'; infoBox.style.top=(y-30)+'px'; }
  else { infoBox.style.left='10px'; infoBox.style.top=(window.innerHeight-48)+'px'; }
  if(ms>0) infoTimeout=setTimeout(()=>{ infoBox.style.display='none'; infoTimeout=null; }, ms);
}

/** ===== ì„ íƒ ëª¨ë“œ ===== */
function enterSelectingMode(mode){ selectingMode=mode; showInfo((mode==='start'?'ì¶œë°œ':'ëª©ì ì§€')+' ë…¸ë“œë¥¼ ìº”ë²„ìŠ¤ì—ì„œ ì„ íƒí•˜ì„¸ìš”.',1800); }

/** ===== ìº”ë²„ìŠ¤ íƒ­/í´ë¦­ í•¸ë“¤ëŸ¬ ===== */
let lastClickTime=0;
function handleCanvasTap(x,y){
  if(!floorImg) return;
  const clickedNode = findNodeAt(x,y);

  if(selectingMode){
    if(clickedNode){
      const sel = (selectingMode==='start')?startSel:endSel;
      sel.innerHTML=''; const opt=document.createElement('option');
      opt.value=clickedNode; opt.textContent=getLabel(clickedNode);
      sel.appendChild(opt); sel.value=clickedNode;
      selectingMode=null; showInfo('ì„ íƒ ì™„ë£Œ: '+clickedNode,1200); draw(); return;
    } else { showInfo('ë…¸ë“œë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”.',1200); return; }
  }

  if(addingNodeMode){
    tempX = x / canvas.width;   // ìƒëŒ€ì¢Œí‘œ
    tempY = y / canvas.height;
    openNodeDialog();
    addingNodeMode=false; return;
  }

  if(clickedNode){
    const now = Date.now();
    if(now - lastClickTime < 300){
      const inputPwd = prompt("ë…¸ë“œ ì‚­ì œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
      if(inputPwd === password){ deleteNode(clickedNode); showInfo('ë…¸ë“œ ì‚­ì œ ì™„ë£Œ',1200,x,y); draw(); }
      else alert("ë¹„ë°€ë²ˆí˜¸ í‹€ë¦¼. ì‚­ì œ ì·¨ì†Œ.");
    } else {
      const n = nodes[clickedNode];
      showInfo(`${getLabel(clickedNode)} : ${n.note||'ì°¸ê³ ì‚¬í•­ ì—†ìŒ'}`,2000,x,y);
    }
    lastClickTime=now;
  }
}

/** ===== ìœ í‹¸ ===== */
function findNodeAt(x,y){
  for(let name of nodeNames){
    const node=nodes[name];
    const absX=node.x*canvas.width;
    const absY=node.y*canvas.height;
    if(Math.hypot(absX-x, absY-y)<=10) return name;
  }
  return null;
}

/** ===== ê·¸ë˜í”„ ì—°ì‚°: Dijkstra ===== */
function distance(n1,n2){ return Math.hypot((n1.x-n2.x)*canvas.width,(n1.y-n2.y)*canvas.height); }
function dijkstra(start,end,allowedNodes=null){
  const visited=new Set(), distances={}, prev={};
  const targetNodes=allowedNodes||nodeNames.slice();
  targetNodes.forEach(n=>distances[n]=Infinity); distances[start]=0;

  while(visited.size<targetNodes.length){
    let minNode=null;
    for(let n of targetNodes){ if(!visited.has(n)&&(minNode===null||distances[n]<distances[minNode])) minNode=n; }
    if(minNode===null) break;
    if(minNode===end) break;
    visited.add(minNode);
    const adj=edges[minNode]||[];
    for(let nb of adj){ if(!targetNodes.includes(nb)) continue; const alt=distances[minNode]+distance(nodes[minNode],nodes[nb]); if(alt<distances[nb]){ distances[nb]=alt; prev[nb]=minNode; } }
  }

  const path=[]; let curr=end;
  while(curr){ path.unshift(curr); curr=prev[curr]; }
  if(path[0]!==start) return [];
  return path;
}

function multiFloorPath(startName,endName){ return dijkstra(startName,endName); }

function findPath(){
  const s=startSel.value; const e=endSel.value;
  if(!s || !e){ alert('ì¶œë°œì§€/ëª©ì ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.'); return; }
  pathNodes=multiFloorPath(s,e)||[];
  if(pathNodes.length===0) alert('ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
  draw();
}

/** ===== ê²€ìƒ‰ ===== */
function normalize(str){ return String(str||'').replace(/\s+/g,'').replace(/[^\wê°€-í£]/g,'').toLowerCase(); }
function searchNodes(query){
  const q=normalize(query); if(q.length>0){ return nodeNames.map(name=>({fullName:name, display:getLabel(name)})).filter(n=>normalize(n.display).includes(q)); }
  return [];
}

function manualSearch(){
  const q = searchInput.value.trim();
  if(!q) return;
  const results = searchNodes(q);
  if(results.length>0){ highlightNode(results[0].fullName); showInfo('ê²€ìƒ‰ ê²°ê³¼: '+results[0].display,1500); }
  else showInfo('ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ',1200);
}

function highlightNode(name){
  if(blinkInterval) clearInterval(blinkInterval);
  blinkNode = name;
  let visible=true;
  blinkInterval = setInterval(()=>{ visible=!visible; draw(visible?blinkNode:null); }, 400);
  setTimeout(()=>{ clearInterval(blinkInterval); blinkInterval=null; blinkNode=null; draw(); }, 4000);
}

/** ===== ë…¸ë“œ ì¶”ê°€/ì‚­ì œ ===== */
function openNodeDialog(){
  document.getElementById('nodeDialog').style.display='block';
  document.getElementById('nodeName').value='';
  document.getElementById('nodeNote').value='';
  selectedType='normal';
}
function closeNodeDialog(){ document.getElementById('nodeDialog').style.display='none'; }
function saveNode(){
  const nameInput = document.getElementById('nodeName').value.trim();
  if(!nameInput){ alert('ë…¸ë“œ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.'); return; }
  const floorType = document.querySelector('input[name="floorType"]:checked').value;
  const floorNum = document.getElementById('floorNumber').value;
  const note = document.getElementById('nodeNote').value.trim();
  const fullName = `${floorType}${floorNum}ì¸µ ${nameInput}`;
  if(nodes[fullName]){ alert('ê°™ì€ ì´ë¦„ì˜ ë…¸ë“œê°€ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤.'); return; }
  nodes[fullName]={x:tempX,y:tempY,floor:floorType+floorNum,type:selectedType,note:note};
  edges[fullName]=[];
  nodeNames.push(fullName);

  // ì…€ë ‰íŠ¸ ë°•ìŠ¤ ì—…ë°ì´íŠ¸
  [startSel,endSel].forEach(sel=>{
    const opt=document.createElement('option'); opt.value=fullName; opt.textContent=getLabel(fullName); sel.appendChild(opt);
  });

  closeNodeDialog();
  draw();
  showInfo('ë…¸ë“œ ì¶”ê°€ ì™„ë£Œ: '+fullName,1200);
}

function deleteNode(name){
  delete nodes[name];
  delete edges[name];
  nodeNames = nodeNames.filter(n=>n!==name);
  Object.keys(edges).forEach(k=>{ edges[k] = edges[k].filter(n=>n!==name); });
  [startSel,endSel].forEach(sel=>{ Array.from(sel.options).forEach(o=>{ if(o.value===name) sel.removeChild(o); }); });
}

/** ===== JSON ë‹¤ìš´ë¡œë“œ ===== */
function downloadJSON(){
  const data = { nodes, edges, nodeNames };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download='locations.json';
  a.click();
  URL.revokeObjectURL(url);
  showInfo('JSON ë‹¤ìš´ë¡œë“œ ì™„ë£Œ',1200);
}

/** ===== ì´ˆê¸°í™” ===== */
function resetAll(clearPath=true){
  pathNodes=[]; if(clearPath) { startSel.value=''; endSel.value=''; }
  draw();
}

/** ===== ê·¸ë¦¬ê¸° ===== */
function draw(blink=null){
  if(!floorImg) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(floorImg,0,0,canvas.width,canvas.height);

  // ê²½ë¡œ ê·¸ë¦¬ê¸°
  if(pathNodes.length>1){
    ctx.strokeStyle='red'; ctx.lineWidth=4; ctx.beginPath();
    pathNodes.forEach((n,i)=>{
      const node=nodes[n];
      const cx=node.x*canvas.width, cy=node.y*canvas.height;
      if(i===0) ctx.moveTo(cx,cy); else ctx.lineTo(cx,cy);
    });
    ctx.stroke();
  }

  // ë…¸ë“œ ê·¸ë¦¬ê¸°
  nodeNames.forEach(n=>{
    const node=nodes[n];
    const cx=node.x*canvas.width, cy=node.y*canvas.height;
    let color='blue';
    if(pathNodes.includes(n)) color='orange';
    if(blink===n) color='lime';
    ctx.fillStyle=color; ctx.strokeStyle='white';
    ctx.beginPath(); ctx.arc(cx,cy,8,0,Math.PI*2); ctx.fill(); ctx.stroke();
  });
}
</script>
</body>
</html>
