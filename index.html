<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>🏬 다층 백화점 길안내 (층간 이동 자동 연결) — 상대좌표 지원</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<style>
:root { color-scheme: light dark; }
* { box-sizing: border-box; }
body { margin:0; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
canvas { border:1px solid #ccc; display:block; cursor:crosshair; }

/* Controls */
#controls {
  position: fixed; top:10px; left:10px;
  background: rgba(255,255,255,0.95); padding:10px; border-radius:10px; z-index:10;
  box-shadow: 0 4px 16px rgba(0,0,0,0.15); backdrop-filter: saturate(1.2) blur(4px);
  max-width: calc(100vw - 20px);
  transition: width 220ms ease, height 220ms ease, padding 220ms ease;
}
#controls .row { display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; align-items:center; }
select, button, input { margin:0; padding:8px 10px; border-radius:8px; border:1px solid #ddd; font-size:14px; }
button { background:#0ea5e9; color:white; border:none; cursor:pointer; }
button.secondary { background:#64748b; }
button.warn { background:#ef4444; }
button:active { transform: translateY(1px); }
#infoBox {
  position: absolute;
  background: rgba(0,0,0,0.7); color:#fff; padding:6px 10px; border-radius:8px; font-weight:600;
  display:none; pointer-events:none; white-space: nowrap; z-index: 9;
}
#nodeDialog {
  display:none; position:fixed; top:50%; left:50%;
  transform:translate(-50%,-50%);
  background:#fff; border:1px solid #e5e7eb; padding:16px;
  border-radius:12px; z-index:1000; box-shadow:0 12px 30px rgba(0,0,0,0.25); width:min(92vw,420px);
}
#nodeDialog h3 { margin:0 0 10px 0; font-size:18px; }
#nodeDialog .typeBtn { margin:4px; padding:6px 10px; cursor:pointer; border:1px solid #ddd; border-radius:999px; background:#f8fafc; }
#nodeDialog label { display:block; margin-top:8px; }
#searchResults {
  position:absolute; background:#fff; border:1px solid #e5e7eb; border-radius:8px;
  display:none; z-index:10; max-height:220px; overflow-y:auto; min-width: 240px; box-shadow: 0 8px 24px rgba(0,0,0,0.12);
}
#searchResults div { padding:6px 8px; cursor:pointer; }
#searchResults div:hover { background:#eef; }

/* Toggle button inside controls */
#toggleControlsBtn { display:inline-flex; align-items:center; justify-content:center; width:40px; height:40px; padding:0; font-size:18px; background:transparent; color:#0f172a; border-radius:8px; border:1px solid transparent; cursor:pointer; }
#toggleControlsBtn:focus { outline:2px solid #cbd5e1; }

/* Collapsed style: hide all but the first row */
#controls.collapsed { width:56px; height:56px; padding:6px; overflow:visible; }
#controls.collapsed strong { display:none; }
#controls.collapsed .row:not(:first-child) { display:none; }
#controls.collapsed .row { margin-top:4px; }

@media (max-width: 640px) {
  #controls { right:10px; left:10px; }
  select, input { min-width: 140px; }
}
</style>
</head>
<body>

<div id="controls" role="region" aria-label="길안내 컨트롤">
  <div class="row" style="align-items:center;">
    <button id="toggleControlsBtn" aria-expanded="true" title="컨트롤 접기/펼치기">☰</button>
    <strong style="margin-left:6px;">층간 길안내</strong>
    <button id="downloadBtn" class="secondary" style="margin-left:8px;" title="현재 노드 데이터를 JSON으로 저장">JSON 다운로드</button>
    <button id="resetBtn" class="warn" title="경로 및 상태 초기화">초기화</button>
  </div>
  <div class="row">
    출발지: <select id="start" title="출발지 선택(캔버스에서 노드를 클릭해도 됩니다)"></select>
    목적지: <select id="end" title="목적지 선택(캔버스에서 노드를 클릭해도 됩니다)"></select>
    <button id="routeBtn" title="최단 경로 찾기">길찾기</button>
  </div>
  <div class="row" style="position:relative;">
    위치 검색: <input type="text" id="searchInput" autocomplete="off" placeholder="예: 1번 계단 / 푸드코트">
    <button id="searchBtn">검색</button>
    <button id="addNodeBtn">노드추가</button>
    <div id="searchResults" role="listbox" aria-label="검색 결과"></div>
  </div>
</div>

<div id="infoBox"></div>
<canvas id="map" aria-label="층간 지도 캔버스"></canvas>

<!-- 노드 입력 다이얼로그 -->
<div id="nodeDialog" role="dialog" aria-modal="true" aria-labelledby="nodeDialogTitle">
  <h3 id="nodeDialogTitle">새 노드 추가</h3>
  <div>
    <label>
      <input type="radio" name="floorType" value="지상" checked> 지상
    </label>
    <label>
      <input type="radio" name="floorType" value="지하"> 지하
    </label>
    <input type="number" id="floorNumber" min="1" value="1" style="width:70px"> 층
  </div>
  <label>노드 이름:
    <input type="text" id="nodeName" placeholder="예: 1번 계단 / 에스1 / 엘리1">
  </label>
  <div style="margin-top:8px;">
    <span>노드 타입:</span><br>
    <button type="button" class="typeBtn" data-type="normal">normal</button>
    <button type="button" class="typeBtn" data-type="elevator">elevator</button>
    <button type="button" class="typeBtn" data-type="stairs">stairs</button>
    <button type="button" class="typeBtn" data-type="escalator">escalator</button>
  </div>
  <label>참고사항:
    <input type="text" id="nodeNote" placeholder="예: 출입구/화장실 방향 등">
  </label>
  <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
    <button id="cancelNodeBtn" class="secondary">취소</button>
    <button id="saveNodeBtn">저장</button>
  </div>
</div>

<script>
// ===== 전역 상태 =====
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');
const searchInput = document.getElementById('searchInput');
const infoBox = document.getElementById('infoBox');
const startSel = document.getElementById('start');
const endSel = document.getElementById('end');
const addNodeBtn = document.getElementById('addNodeBtn');
const searchResults = document.getElementById('searchResults');
const routeBtn = document.getElementById('routeBtn');
const resetBtn = document.getElementById('resetBtn');
const downloadBtn = document.getElementById('downloadBtn');
const toggleBtn = document.getElementById('toggleControlsBtn');
const controls = document.getElementById('controls');

let floorImg=null, nodes={}, edges={}, nodeNames=[], blinkNode=null, blinkInterval=null;
let pathNodes=[], selectingMode=null, addingNodeMode=false, tempX=0, tempY=0, selectedType='normal';
let password='knp123';
let imageLoaded=false;

// ===== 캔버스 반응형 =====
function resizeCanvas(){ 
  canvas.width=window.innerWidth; 
  canvas.height=window.innerHeight; 
  draw(); 
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', ()=>setTimeout(resizeCanvas,300));

// ===== 이미지/JSON 자동 로드 =====
function loadFloorImage(){ return new Promise((resolve,reject)=>{
  const img=new Image(); img.onload=()=>{ floorImg=img; imageLoaded=true; resolve(); };
  img.onerror=reject; img.src='floorplan.png';
}); }

function loadLocations(){
  return fetch('locations.json',{cache:'no-store'})
    .then(r=>r.ok?r.json():Promise.reject('locations.json 로드 실패'))
    .then(data=>{
      nodes=data.nodes||{}; edges=data.edges||{}; nodeNames=data.nodeNames||Object.keys(nodes);
      nodeNames.forEach(n=>edges[n]=edges[n]||[]);
    }).catch(e=>{ console.warn(e); nodes={}; edges={}; nodeNames=[]; });
}

// ===== 초기화 =====
(async function init(){ await Promise.allSettled([loadFloorImage(),loadLocations()]); bindUI(); resizeCanvas(); draw(); })();

// ===== UI 바인딩 =====
function bindUI(){
  startSel.addEventListener('click',()=>enterSelectingMode('start'));
  endSel.addEventListener('click',()=>enterSelectingMode('end'));
  routeBtn.addEventListener('click', findPath);
  resetBtn.addEventListener('click', ()=>resetAll(false));
  downloadBtn.addEventListener('click', downloadJSON);
  document.getElementById('searchBtn').addEventListener('click', manualSearch);

  canvas.addEventListener('click', e=>handleCanvasTap(e.offsetX,e.offsetY));
  canvas.addEventListener('touchstart', e=>{
    const t=e.changedTouches[0]; const rect=canvas.getBoundingClientRect();
    handleCanvasTap(t.clientX-rect.left, t.clientY-rect.top);
  },{passive:true});

  addNodeBtn.addEventListener('click', ()=>{
    const inputPwd=prompt("노드추가 비밀번호를 입력하세요:");
    if(inputPwd===password){ showInfo('캔버스에서 노드를 추가할 위치를 탭/클릭하세요.',2000); addingNodeMode=true; }
    else alert("비밀번호 틀림. 노드추가 취소.");
  });

  searchInput.addEventListener('input', ()=>{ 
    const results=searchNodes(searchInput.value); 
    searchResults.innerHTML=''; 
    if(results.length>0){ searchResults.style.display='block'; 
      results.forEach(r=>{ 
        const div=document.createElement('div'); 
        div.textContent=r.display; 
        div.addEventListener('click', ()=>{ searchInput.value=getLabel(r.fullName); searchResults.style.display='none'; highlightNode(r.fullName); });
        searchResults.appendChild(div);
      });
    } else searchResults.style.display='none';
  });

  document.querySelectorAll('#nodeDialog .typeBtn').forEach(btn=>btn.addEventListener('click',()=>selectedType=btn.dataset.type));
  document.getElementById('cancelNodeBtn').addEventListener('click', closeNodeDialog);
  document.getElementById('saveNodeBtn').addEventListener('click', saveNode);

  toggleBtn.addEventListener('click', e=>{
    e.stopPropagation();
    const collapsed=controls.classList.toggle('collapsed');
    toggleBtn.setAttribute('aria-expanded',String(!collapsed));
    toggleBtn.title=collapsed?'컨트롤 펼치기':'컨트롤 접기';
  });

  document.addEventListener('click', e=>{ if(!controls.contains(e.target)) searchResults.style.display='none'; });
}

// ===== 정보 표시 =====
let infoTimeout=null;
function showInfo(text, ms=2000, x=null, y=null){
  if(infoTimeout){ clearTimeout(infoTimeout); infoTimeout=null; }
  infoBox.style.display='block'; infoBox.textContent=text;
  if(x!==null && y!==null){ infoBox.style.left=(x+10)+'px'; infoBox.style.top=(y-30)+'px'; }
  else { infoBox.style.left='10px'; infoBox.style.top=(window.innerHeight-48)+'px'; }
  if(ms>0) infoTimeout=setTimeout(()=>{ infoBox.style.display='none'; infoTimeout=null; }, ms);
}

// ===== 선택 모드 =====
function enterSelectingMode(mode){ selectingMode=mode; showInfo((mode==='start'?'출발':'목적지')+' 노드를 캔버스에서 선택하세요.',1800); }

// ===== 좌표 변환 =====
function getNodeDisplayCoords(name){
  const n=nodes[name]; if(!n) return null;
  if(typeof n.x==='number' && typeof n.y==='number' && n.x<=1 && n.y<=1) return {x:n.x*canvas.width, y:n.y*canvas.height};
  if(imageLoaded && floorImg && floorImg.width && floorImg.height) return {x:(n.x/floorImg.width)*canvas.width, y:(n.y/floorImg.height)*canvas.height};
  return {x:n.x,y:n.y};
}
function getNodeNormalizedCoordsFromCanvas(px,py){ return {x:px/canvas.width, y:py/canvas.height}; }

// ===== 캔버스 클릭/탭 =====
let lastClickTime=0;
function handleCanvasTap(x,y){
  const clickedNode=findNodeAt(x,y);
  if(selectingMode){
    if(clickedNode){
      const sel=(selectingMode==='start')?startSel:endSel;
      sel.innerHTML=''; const opt=document.createElement('option'); opt.value=clickedNode; opt.textContent=getLabel(clickedNode); sel.appendChild(opt);
      sel.value=clickedNode; selectingMode=null; showInfo('선택 완료: '+clickedNode,1200); draw(); return;
    } else { showInfo('노드를 클릭하여 선택하세요.',1200); return; }
  }

  if(addingNodeMode){ tempX=x; tempY=y; openNodeDialog(); addingNodeMode=false; return; }

  if(clickedNode){
    const now=Date.now();
    if(now-lastClickTime<300){
      const inputPwd=prompt("노드 삭제 비밀번호를 입력하세요:");
      if(inputPwd===password){ deleteNode(clickedNode); showInfo('노드 삭제 완료',1200,x,y); draw(); }
      else alert("비밀번호 틀림. 삭제 취소.");
    } else { const n=nodes[clickedNode]; showInfo(`${getLabel(clickedNode)} : ${n.note||'참고사항 없음'}`,2000,x,y); }
    lastClickTime=now;
  }
}

function findNodeAt(x,y){ for(let n of nodeNames){ const d=getNodeDisplayCoords(n); if(!d) continue; if(Math.hypot(d.x-x,d.y-y)<=12) return n; } return null; }

// ===== Dijkstra 경로 =====
function distanceByDisplay(aName,bName){ const a=getNodeDisplayCoords(aName), b=getNodeDisplayCoords(bName); if(!a||!b) return Infinity; return Math.hypot(a.x-b.x,a.y-b.y); }
function dijkstra(start,end,allowedNodes=null){
  const visited=new Set(), distances={}, prev={};
  const targetNodes=allowedNodes||nodeNames.slice();
  targetNodes.forEach(n=>distances[n]=Infinity); distances[start]=0;
  while(visited.size<targetNodes.length){
    let minNode=null;
    for(let n of targetNodes){ if(!visited.has(n)&&(minNode===null||distances[n]<distances[minNode])) minNode=n; }
    if(minNode===null) break; if(minNode===end) break;
    visited.add(minNode);
    const adj=edges[minNode]||[];
    for(let nb of adj){ if(!targetNodes.includes(nb)) continue; const alt=distances[minNode]+distanceByDisplay(minNode,nb); if(alt<distances[nb]){ distances[nb]=alt; prev[nb]=minNode; } }
  }
  const path=[]; let curr=end; while(curr){ path.unshift(curr); curr=prev[curr]; } if(path[0]!==start) return []; return path;
}
function multiFloorPath(s,e){ return dijkstra(s,e); }
function findPath(){ const s=startSel.value,e=endSel.value; if(!s||!e){ alert('출발지/목적지를 선택하세요.'); return; } pathNodes=multiFloorPath(s,e)||[]; if(pathNodes.length===0) alert('경로를 찾을 수 없습니다.'); draw(); }

// ===== 검색 =====
function normalize(str){ return String(str||'').replace(/\s+/g,'').replace(/[^\w가-힣]/g,'').toLowerCase(); }
function searchNodes(query){ const q=normalize(query); if(q.length<2) return []; const res=[]; for(let name of nodeNames){ const node=nodes[name]; const fields=[name,node.type,node.note||'']; for(let f of fields){ if(normalize(f).includes(q)){ res.push({fullName:name, display:`${getLabel(name)} [${node.type}] ${node.note||''}`}); break; } } } return res; }
function manualSearch(){ const val=searchInput.value.trim(); if(!val){ alert('검색어를 입력하세요.'); return; } const results=searchNodes(val); if(results.length>0) highlightNode(results[0].fullName); else alert('노드를 찾을 수 없습니다.'); }

// ===== 깜빡임 =====
function highlightNode(name=null){
  const nodeToBlink=name||nodeNames.find(n=>getLabel(n)===searchInput.value); if(!nodeToBlink){ alert("노드 없음"); return; }
  if(blinkInterval) clearInterval(blinkInterval); blinkNode=nodeToBlink;
  let opacity=0.2, growing=true;
  blinkInterval=setInterval(()=>{ if(growing){ opacity+=0.1;if(opacity>=0.85) growing=false; } else { opacity-=0.1; if(opacity<=0.2) growing=true; } draw(opacity); },100);
  setTimeout(()=>{ clearInterval(blinkInterval); blinkInterval=null; blinkNode=null; draw(); },3000);
}

// ===== 초기화 =====
function resetAll(skipConfirm=false){ if(!skipConfirm&&!confirm("경로 및 강조를 초기화하시겠습니까?")) return; pathNodes=[]; if(blinkInterval){ clearInterval(blinkInterval); blinkInterval=null; } blinkNode=null; selectingMode=null; addingNodeMode=false; if(infoTimeout){ clearTimeout(infoTimeout); infoTimeout=null; } infoBox.style.display='none'; startSel.innerHTML=''; endSel.innerHTML=''; searchResults.style.display='none'; draw(); }

// ===== 노드 다이얼로그 =====
function openNodeDialog(){ document.getElementById('nodeDialog').style.display='block'; }
function closeNodeDialog(){ document.getElementById('nodeDialog').style.display='none'; }
function addEdge(a,b){ edges[a]=edges[a]||[]; edges[b]=edges[b]||[]; if(!edges[a].includes(b)) edges[a].push(b); if(!edges[b].includes(a)) edges[b].push(a); }
function saveNode(){
  const name=document.getElementById('nodeName').value.trim();
  const floor=document.querySelector('input[name="floorType"]:checked').value+document.getElementById('floorNumber').value+'층';
  const note=document.getElementById('nodeNote').value;
  if(!name){ alert("노드 이름을 입력하세요."); return; }
  const fullName=`${floor} ${name}`;
  if(nodes[fullName]){ alert("이미 존재하는 노드입니다."); return; }
  const norm=getNodeNormalizedCoordsFromCanvas(tempX,tempY);
  nodes[fullName]={x:Number(norm.x.toFixed(6)),y:Number(norm.y.toFixed(6)),floor,type:selectedType,note};
  nodeNames.push(fullName);
  nodeNames.forEach(n=>{ if(n!==fullName && nodes[n].floor===floor) addEdge(n,fullName); });
  if(selectedType==='escalator'||selectedType==='stairs'||selectedType==='elevator'){
    for(let n of nodeNames){ if(n===fullName) continue; if(nodes[n].type===selectedType && getLabel(n)===getLabel(fullName)) addEdge(n,fullName); }
  }
  closeNodeDialog(); draw(); document.getElementById('nodeName').value=''; document.getElementById('nodeNote').value='';
}
function deleteNode(name){ delete nodes[name]; nodeNames=nodeNames.filter(n=>n!==name); delete edges[name]; for(let k in edges) edges[k]=edges[k].filter(n=>n!==name); pathNodes=[]; }

// ===== JSON 다운로드 =====
function downloadJSON(){ const data={nodes,edges,nodeNames}; const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='locations.json'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showInfo('locations.json 다운로드 완료',1400); }

// ===== 라벨 =====
function getLabel(fullName){ const s=fullName.split(' '); return s.length>1?s.slice(1).join(' ').trim():fullName; }

// ===== 그리기 =====
function draw(opacity=1){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(floorImg) ctx.drawImage(floorImg,0,0,canvas.width,canvas.height);
  if(pathNodes.length>1){ ctx.strokeStyle='red'; ctx.lineWidth=4; ctx.lineJoin='round'; ctx.beginPath(); pathNodes.forEach((n,i)=>{ const d=getNodeDisplayCoords(n); if(!d) return; i===0?ctx.moveTo(d.x,d.y):ctx.lineTo(d.x,d.y); }); ctx.stroke(); }
  ctx.font='12px system-ui'; ctx.textBaseline='middle';
  nodeNames.forEach(n=>{ const node=nodes[n]; if(!node) return; const d=getNodeDisplayCoords(n); if(!d) return; let radius=9; if(n===blinkNode) radius=14; ctx.beginPath(); ctx.arc(d.x,d.y,radius,0,Math.PI*2); 
    ctx.fillStyle=n===blinkNode?`rgba(255,255,0,${opacity})`:pathNodes.includes(n)?'red':node.type==='normal'?'#2563eb':node.type==='stairs'?'#f59e0b':node.type==='elevator'?'#16a34a':'#9333ea'; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.stroke();
    ctx.fillStyle='black'; ctx.fillText(getLabel(n),d.x+radius+6,d.y);
  });
}

// ===== 접근성: select 옵션 =====
function refreshSelectOptions(){ 
  [startSel,endSel].forEach(sel=>{ const curr=sel.value; sel.innerHTML='<option value="">(캔버스에서 선택 가능)</option>'; nodeNames.forEach(n=>{ const opt=document.createElement('option'); opt.value=n; opt.textContent=getLabel(n); sel.appendChild(opt); }); if(curr&&nodeNames.includes(curr)) sel.value=curr; });
}
setInterval(refreshSelectOptions,1500);
</script>

</body>
</html>
