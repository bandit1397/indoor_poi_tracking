<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>층간 길안내 (상대좌표 버전)</title>
<style>
  :root{color-scheme:light dark}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  canvas{display:block;cursor:crosshair}
  #controls{position:fixed;left:10px;top:10px;background:rgba(255,255,255,.95);padding:10px;border-radius:10px;z-index:20;box-shadow:0 6px 18px rgba(0,0,0,.12);max-width:calc(100vw-20px)}
  #controls .row{display:flex;flex-wrap:wrap;gap:6px;align-items:center;margin-bottom:6px}
  input,select,button{padding:8px;border-radius:8px;border:1px solid #ddd;font-size:14px}
  button{background:#0ea5e9;color:#fff;border:none;cursor:pointer}
  button.secondary{background:#64748b}
  button.warn{background:#ef4444}
  #searchResults{position:absolute;left:10px;top:100%;background:#fff;border:1px solid #e5e7eb;border-radius:8px;display:none;z-index:30;max-height:220px;overflow:auto;min-width:220px}
  #searchResults div{padding:6px;cursor:pointer}
  #searchResults div:hover{background:#eef}
  #nodeDialog{display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:40;background:#fff;padding:14px;border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,.25);width:min(92vw,420px)}
  #infoBox{position:fixed;left:10px;bottom:10px;background:rgba(0,0,0,.75);color:#fff;padding:8px 12px;border-radius:8px;z-index:50;display:none}
  @media(max-width:640px){#controls{left:10px;right:10px}}
</style>
</head>
<body>
<div id="controls" role="region" aria-label="길안내 컨트롤">
  <div class="row">
    <strong>층간 길안내</strong>
    <button id="downloadBtn" class="secondary">JSON 다운로드</button>
    <button id="resetBtn" class="warn">초기화</button>
  </div>
  <div class="row">
    출발지: <select id="start"></select>
    목적지: <select id="end"></select>
    <button id="routeBtn">길찾기</button>
  </div>
  <div class="row" style="position:relative">
    위치 검색: <input id="searchInput" placeholder="예: 1번 계단" />
    <button id="searchBtn">검색</button>
    <button id="addNodeBtn">노드추가</button>
    <div id="searchResults" role="listbox" aria-label="검색 결과"></div>
  </div>
</div>

<div id="infoBox"></div>

<canvas id="map" aria-label="층간 지도 캔버스"></canvas>

<!-- 노드 다이얼로그 -->
<div id="nodeDialog" role="dialog" aria-modal="true" aria-labelledby="nodeDialogTitle">
  <h3 id="nodeDialogTitle">새 노드 추가</h3>
  <div>
    <label><input type="radio" name="floorType" value="지상" checked> 지상</label>
    <label><input type="radio" name="floorType" value="지하"> 지하</label>
    <input id="floorNumber" type="number" value="1" min="1" style="width:70px" /> 층
  </div>
  <div style="margin-top:8px">
    <label>노드 이름: <input id="nodeName" type="text" style="width:100%" placeholder="예: 1번 계단" /></label>
  </div>
  <div style="margin-top:8px">
    <span>노드 타입:</span><br>
    <button class="typeBtn" data-type="normal" type="button">normal</button>
    <button class="typeBtn" data-type="elevator" type="button">elevator</button>
    <button class="typeBtn" data-type="stairs" type="button">stairs</button>
    <button class="typeBtn" data-type="escalator" type="button">escalator</button>
  </div>
  <div style="margin-top:8px">
    <label>참고: <input id="nodeNote" type="text" style="width:100%" /></label>
  </div>
  <div style="margin-top:12px;text-align:right">
    <button id="cancelNodeBtn" type="button" class="secondary">취소</button>
    <button id="saveNodeBtn" type="button">저장</button>
  </div>
</div>

<script>
/* ====== 상태 ====== */
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');

const startSel = document.getElementById('start');
const endSel = document.getElementById('end');
const searchInput = document.getElementById('searchInput');
const searchResults = document.getElementById('searchResults');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const routeBtn = document.getElementById('routeBtn');
const addNodeBtn = document.getElementById('addNodeBtn');
const infoBox = document.getElementById('infoBox');

let floorImg = new Image();
floorImg.src = 'floorplan.png'; // same folder
let nodes = {};     // { "지상1층 출입구": { x:0.1, y:0.9, floor:"지상1층", type:"normal", note:"" }, ... }
let edges = {};     // adjacency list
let nodeNames = [];
let blinkNode = null;
let blinkInterval = null;
let pathNodes = [];
let selectingMode = null; // 'start'|'end'|null
let addingNodeMode = false;
let tempX = 0, tempY = 0; // relative coords (0..1) for new node
let selectedType = 'normal';
const password = 'knp123';

let infoTimeout = null;
function showInfo(text, ms=1800){
  if(infoTimeout) clearTimeout(infoTimeout);
  infoBox.style.display='block'; infoBox.textContent=text;
  if(ms>0) infoTimeout = setTimeout(()=>{ infoBox.style.display='none'; infoTimeout=null; }, ms);
}

/* ====== 캔버스 사이즈 ====== */
function resizeCanvas(){
  canvas.width = Math.max(window.innerWidth, document.documentElement.clientWidth || 0);
  canvas.height = Math.max(window.innerHeight, document.documentElement.clientHeight || 0);
  draw();
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', ()=> setTimeout(resizeCanvas, 200));

/* ====== 초기 로드 JSON(있다면) ====== */
async function loadLocations(){
  try{
    const res = await fetch('locations.json', {cache:'no-store'});
    if(!res.ok) throw new Error('no json');
    const data = await res.json();
    // assume data.nodes are relative coords already
    nodes = data.nodes || {};
    edges = data.edges || {};
    nodeNames = data.nodeNames || Object.keys(nodes);
    nodeNames.forEach(n => { edges[n] = edges[n] || []; });
  }catch(e){
    // no json -> start empty
    nodes = {}; edges = {}; nodeNames = [];
    console.warn('locations.json not loaded or missing, starting empty.');
  }
}

/* ====== init ====== */
(async function init(){
  await loadLocations();
  // wait floor image load (may already be cached)
  floorImg.onload = () => { resizeCanvas(); draw(); };
  floorImg.onerror = ()=>{ console.warn('floorplan.png not found'); resizeCanvas(); draw(); };
  bindUI();
  resizeCanvas();
  draw();
})();

/* ====== 유틸 ====== */
function getLabel(full){ const s = full.split(' '); return s.length>1? s.slice(1).join(' ').trim(): full; }

/* ====== UI 바인딩 ====== */
function bindUI(){
  // selection by clicking canvas
  startSel.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); selectingMode='start'; showInfo('출발지로 선택할 노드를 캔버스에서 탭하세요',1500); startSel.blur(); });
  endSel.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); selectingMode='end'; showInfo('목적지로 선택할 노드를 캔버스에서 탭하세요',1500); endSel.blur(); });

  routeBtn.addEventListener('click', findPath);
  resetBtn.addEventListener('click', ()=>{ pathNodes=[]; blinkNode=null; clearBlink(); startSel.value=''; endSel.value=''; draw(); });
  downloadBtn.addEventListener('click', downloadJSON);

  searchInput.addEventListener('input', ()=>{
    const q = searchInput.value.trim();
    const res = searchNodes(q);
    searchResults.innerHTML='';
    if(res.length>0){
      res.forEach(r=>{ const d = document.createElement('div'); d.textContent=r.display; d.addEventListener('click', ()=>{ searchInput.value=getLabel(r.fullName); searchResults.style.display='none'; highlightNode(r.fullName); }); searchResults.appendChild(d); });
      searchResults.style.display='block';
    } else searchResults.style.display='none';
  });
  document.getElementById('searchBtn').addEventListener('click', ()=>{ const q=searchInput.value.trim(); if(!q) return; const r=searchNodes(q); if(r.length) { highlightNode(r[0].fullName); showInfo('검색: '+r[0].display,1200);} else showInfo('검색결과 없음',1200); });

  // touch & click canvas
  canvas.addEventListener('touchstart', (ev)=>{ const t = ev.changedTouches[0]; const r = canvas.getBoundingClientRect(); handleCanvasTap(t.clientX - r.left, t.clientY - r.top); }, {passive:true});
  canvas.addEventListener('click', (ev)=>{ const r = canvas.getBoundingClientRect(); handleCanvasTap(ev.clientX - r.left, ev.clientY - r.top); });

  addNodeBtn.addEventListener('click', ()=>{
    const pwd = prompt('노드추가 비밀번호를 입력하세요:');
    if(pwd === password){ addingNodeMode = true; showInfo('캔버스에서 추가할 위치를 탭하세요',2000); } else alert('비밀번호 틀림');
  });

  // node dialog buttons
  document.querySelectorAll('.typeBtn').forEach(b=>b.addEventListener('click', (e)=>{ selectedType = e.currentTarget.dataset.type; }));
  document.getElementById('cancelNodeBtn').addEventListener('click', ()=>{ document.getElementById('nodeDialog').style.display='none'; });
  document.getElementById('saveNodeBtn').addEventListener('click', saveNode);
}

/* ====== 캔버스 탭 처리 (노드 선택/추가/삭제) ====== */
let lastTap = 0;
function handleCanvasTap(x,y){
  // 1) selecting mode (start/end)
  const clicked = findNodeAt(x,y);
  if(selectingMode){
    if(clicked){
      const sel = (selectingMode === 'start') ? startSel : endSel;
      sel.innerHTML=''; const opt=document.createElement('option'); opt.value=clicked; opt.textContent=getLabel(clicked); sel.appendChild(opt); sel.value=clicked;
      selectingMode = null; showInfo('선택 완료: '+clicked,1000); draw(); return;
    } else { showInfo('노드 위를 탭하세요',1000); return; }
  }

  // 2) adding node mode
  if(addingNodeMode){
    tempX = x / canvas.width; tempY = y / canvas.height; // RELATIVE
    openAddDialog(); addingNodeMode = false; return;
  }

  // 3) click on existing node -> single tap show info, double tap delete (with pwd)
  if(clicked){
    const now = Date.now();
    if(now - lastTap < 350){
      const pwd = prompt('노드 삭제 비밀번호를 입력하세요:');
      if(pwd === password){ deleteNode(clicked); showInfo('삭제됨: '+clicked,1100); draw(); } else alert('비밀번호 틀림');
    } else {
      const n = nodes[clicked];
      showInfo(getLabel(clicked) + ' — ' + (n.note || '참고사항 없음'), 1400);
    }
    lastTap = now;
    return;
  }
}

/* ====== 노드 탐색 (화면좌표 입력) ====== */
function findNodeAt(screenX, screenY){
  for(const name of nodeNames){
    const n = nodes[name];
    const ax = n.x * canvas.width;
    const ay = n.y * canvas.height;
    if(Math.hypot(ax - screenX, ay - screenY) <= 12) return name;
  }
  return null;
}

/* ====== 거리 & Dijkstra (상대좌표 기반 거리계산) ====== */
function distance(a,b){
  return Math.hypot((a.x - b.x) * canvas.width, (a.y - b.y) * canvas.height);
}
function dijkstra(start, end, allowed = null){
  const targets = allowed || nodeNames.slice();
  const dist = {}, prev = {};
  targets.forEach(t => dist[t] = Infinity);
  dist[start] = 0;
  const visited = new Set();
  while(visited.size < targets.length){
    let u = null;
    for(const t of targets) if(!visited.has(t) && (u===null || dist[t] < dist[u])) u = t;
    if(u === null) break;
    if(u === end) break;
    visited.add(u);
    const adj = edges[u] || [];
    for(const v of adj){
      if(!targets.includes(v)) continue;
      const alt = dist[u] + distance(nodes[u], nodes[v]);
      if(alt < dist[v]){ dist[v] = alt; prev[v] = u; }
    }
  }
  const path = []; let cur = end;
  while(cur){ path.unshift(cur); cur = prev[cur]; }
  if(path[0] !== start) return [];
  return path;
}
function findPath(){
  const s = startSel.value, e = endSel.value;
  if(!s || !e){ alert('출발지/목적지를 선택하세요'); return; }
  pathNodes = dijkstra(s,e) || [];
  if(pathNodes.length === 0) alert('경로를 찾을 수 없습니다.');
  draw();
}

/* ====== 검색 ====== */
function normalize(str){ return String(str||'').replace(/\s+/g,'').replace(/[^\w가-힣]/g,'').toLowerCase(); }
function searchNodes(q){
  const qq = normalize(q);
  if(qq.length < 1) return [];
  const out = [];
  for(const name of nodeNames){
    const n = nodes[name];
    const fields = [name, n.type, n.note || ''];
    for(const f of fields){
      if(normalize(f).includes(qq)){ out.push({ fullName: name, display: getLabel(name) + ' [' + n.type + '] ' + (n.note||'') }); break; }
    }
  }
  return out;
}
function highlightNode(name){
  if(blinkInterval) clearInterval(blinkInterval);
  blinkNode = name;
  let visible = true;
  blinkInterval = setInterval(()=>{ visible = !visible; draw(visible ? name : null); }, 350);
  setTimeout(()=>{ clearInterval(blinkInterval); blinkInterval = null; blinkNode = null; draw(); }, 3500);
}

/* ====== 추가 다이얼로그 저장/삭제 ====== */
function openAddDialog(){ document.getElementById('nodeDialog').style.display='block'; document.getElementById('nodeName').focus(); }
function closeAddDialog(){ document.getElementById('nodeDialog').style.display='none'; }

document.getElementById('cancelNodeBtn').addEventListener('click', ()=>{ closeAddDialog(); });

function saveNode(){
  const name = document.getElementById('nodeName').value.trim();
  if(!name){ alert('노드 이름 입력'); return; }
  const floorType = document.querySelector('input[name="floorType"]:checked').value;
  const floorNum = document.getElementById('floorNumber').value || '1';
  const note = document.getElementById('nodeNote').value || '';
  const full = `${floorType}${floorNum}층 ${name}`;
  if(nodes[full]){ alert('이미 존재하는 노드명입니다'); return; }
  nodes[full] = { x: tempX, y: tempY, floor: floorType + floorNum, type: selectedType, note };
  edges[full] = edges[full] || [];
  nodeNames.push(full);

  // 자동 연결: 같은 층의 모든 노드와 기본 연결
  nodeNames.forEach(n=>{
    if(n === full) return;
    if(nodes[n].floor === nodes[full].floor) { edges[n] = edges[n] || []; if(!edges[n].includes(full)) edges[n].push(full); if(!edges[full].includes(n)) edges[full].push(n); }
  });

  // 층간 연결: 동일 라벨의 elevator/stairs/escalator끼리 연결
  if(['elevator','stairs','escalator'].includes(selectedType)){
    for(const n of nodeNames){
      if(n === full) continue;
      if(nodes[n].type === selectedType && getLabel(n) === getLabel(full)){
        edges[n] = edges[n] || []; if(!edges[n].includes(full)) edges[n].push(full); if(!edges[full].includes(n)) edges[full].push(n);
      }
    }
  }

  // select 옵션 업데이트
  const opt1 = document.createElement('option'); opt1.value=full; opt1.textContent=getLabel(full); startSel.appendChild(opt1);
  const opt2 = document.createElement('option'); opt2.value=full; opt2.textContent=getLabel(full); endSel.appendChild(opt2);

  closeAddDialog(); draw(); showInfo('노드 추가: ' + full, 1200);
}

/* ====== 삭제 (외부 호출) ====== */
function deleteNode(name){
  delete nodes[name];
  delete edges[name];
  nodeNames = nodeNames.filter(n=>n !== name);
  for(const k in edges) edges[k] = edges[k].filter(x=>x!==name);
  // remove options
  [startSel,endSel].forEach(sel=>{ Array.from(sel.options).forEach(o=>{ if(o.value === name) sel.removeChild(o); }); });
}

/* ====== JSON 저장/다운로드 ====== */
function downloadJSON(){
  const payload = { nodes, edges, nodeNames };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'locations.json';
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  showInfo('locations.json 다운로드 완료',1200);
}

/* ====== 그리기 ====== */
function clearBlink(){ if(blinkInterval){ clearInterval(blinkInterval); blinkInterval=null; blinkNode=null; } }

function draw(blinkName=null){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw floorplan (stretched to canvas; we use relative coords)
  if(floorImg && floorImg.complete) ctx.drawImage(floorImg, 0, 0, canvas.width, canvas.height);
  else { ctx.fillStyle='#f7f7f7'; ctx.fillRect(0,0,canvas.width,canvas.height); }

  // draw path
  if(pathNodes.length > 1){
    ctx.lineWidth = 4; ctx.strokeStyle = 'red'; ctx.beginPath();
    pathNodes.forEach((nm,i)=>{
      if(!nodes[nm]) return;
      const nx = nodes[nm].x * canvas.width, ny = nodes[nm].y * canvas.height;
      if(i===0) ctx.moveTo(nx, ny); else ctx.lineTo(nx, ny);
    });
    ctx.stroke();
  }

  // draw nodes
  ctx.font = '12px system-ui';
  ctx.textBaseline = 'middle';
  for(const nm of nodeNames){
    const n = nodes[nm]; if(!n) continue;
    const x = n.x * canvas.width, y = n.y * canvas.height;
    let fill = '#2563eb';
    if(pathNodes.includes(nm)) fill = '#ef4444';
    if(blinkName && blinkName === nm) fill = '#facc15';
    ctx.beginPath(); ctx.arc(x,y,9,0,Math.PI*2); ctx.fillStyle = fill; ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 1; ctx.stroke();
    // label to right
    ctx.fillStyle = '#000'; ctx.fillText(getLabel(nm), x + 12, y);
  }
}

/* ====== select options 자동 갱신 ===== */
setInterval(()=>{ 
  // keep current value
  const curS = startSel.value, curE = endSel.value;
  startSel.innerHTML = '<option value="">(캔버스에서 선택)</option>';
  endSel.innerHTML = '<option value="">(캔버스에서 선택)</option>';
  nodeNames.forEach(nm=>{
    const o1 = document.createElement('option'); o1.value = nm; o1.textContent = getLabel(nm); startSel.appendChild(o1);
    const o2 = document.createElement('option'); o2.value = nm; o2.textContent = getLabel(nm); endSel.appendChild(o2);
  });
  if(curS && nodeNames.includes(curS)) startSel.value = curS;
  if(curE && nodeNames.includes(curE)) endSel.value = curE;
}, 1000);

</script>
</body>
</html>
