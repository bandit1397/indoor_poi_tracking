<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>ğŸ¬ ë‹¤ì¸µ ë°±í™”ì  ê¸¸ì•ˆë‚´ (ë°˜ì‘í˜• - ì›ë³¸ ì¢Œí‘œ ê¸°ì¤€)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<style>
  :root { color-scheme: light dark; }
  * { box-sizing: border-box; }
  body { margin:0; overflow:hidden; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  canvas { display:block; cursor:crosshair; }
  #controls {
    position: fixed; top:10px; left:10px;
    background: rgba(255,255,255,0.95); padding:10px; border-radius:10px; z-index:12;
    box-shadow: 0 6px 18px rgba(0,0,0,0.12); max-width: calc(100vw - 20px);
  }
  .row { display:flex; flex-wrap:wrap; gap:6px; align-items:center; }
  select, button, input { margin:0; padding:8px 10px; border-radius:8px; border:1px solid #ddd; font-size:14px; }
  button { background:#0ea5e9; color:white; border:none; cursor:pointer; }
  button.secondary { background:#64748b; }
  button.warn { background:#ef4444; }
  #infoBox {
    position:absolute; background: rgba(0,0,0,0.72); color:#fff; padding:6px 10px; border-radius:8px;
    display:none; pointer-events:none; white-space: nowrap; z-index:11;
  }
  #nodeDialog { display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#fff; border-radius:12px; padding:16px; z-index:20; box-shadow:0 12px 30px rgba(0,0,0,0.25); width:min(92vw,420px); }
  #nodeDialog h3 { margin:0 0 10px 0; }
  .typeBtn { margin:4px; padding:6px 10px; cursor:pointer; border:1px solid #ddd; border-radius:999px; background:#f8fafc; }
  #searchResults { position:absolute; background:#fff; border:1px solid #e5e7eb; display:none; z-index:13; max-height:220px; overflow-y:auto; min-width:240px; box-shadow:0 8px 24px rgba(0,0,0,0.12); }
  #searchResults div { padding:6px 8px; cursor:pointer; }
  #searchResults div:hover { background:#eef; }
  @media (max-width:640px){ #controls { left:10px; right:10px; } select, input { min-width:120px; } }
</style>
</head>
<body>

<div id="controls" role="region" aria-label="ê¸¸ì•ˆë‚´ ì»¨íŠ¸ë¡¤">
  <div class="row">
    <strong>ì¸µê°„ ê¸¸ì•ˆë‚´</strong>
    <button id="downloadBtn" class="secondary" title="í˜„ì¬ ë…¸ë“œ ë°ì´í„°ë¥¼ JSONìœ¼ë¡œ ì €ì¥">JSON ë‹¤ìš´ë¡œë“œ</button>
    <button id="resetBtn" class="warn" title="ê²½ë¡œ ë° ìƒíƒœ ì´ˆê¸°í™”">ì´ˆê¸°í™”</button>
  </div>
  <div class="row" style="margin-top:6px;">
    ì¶œë°œì§€: <select id="start" title="ì¶œë°œì§€ ì„ íƒ"></select>
    ëª©ì ì§€: <select id="end" title="ëª©ì ì§€ ì„ íƒ"></select>
    <button id="routeBtn">ê¸¸ì°¾ê¸°</button>
  </div>
  <div class="row" style="position:relative; margin-top:6px;">
    ìœ„ì¹˜ ê²€ìƒ‰: <input type="text" id="searchInput" autocomplete="off" placeholder="ì˜ˆ: 1ë²ˆ ê³„ë‹¨ / í‘¸ë“œì½”íŠ¸">
    <button id="searchBtn">ê²€ìƒ‰</button>
    <button id="addNodeBtn">ë…¸ë“œì¶”ê°€</button>
    <div id="searchResults" role="listbox" aria-label="ê²€ìƒ‰ ê²°ê³¼"></div>
  </div>
</div>

<div id="infoBox"></div>
<canvas id="map" aria-label="ì¸µê°„ ì§€ë„ ìº”ë²„ìŠ¤"></canvas>

<!-- ë…¸ë“œ ì…ë ¥ ë‹¤ì´ì–¼ë¡œê·¸ -->
<div id="nodeDialog" role="dialog" aria-modal="true" aria-labelledby="nodeDialogTitle">
  <h3 id="nodeDialogTitle">ìƒˆ ë…¸ë“œ ì¶”ê°€</h3>
  <div>
    <label><input type="radio" name="floorType" value="ì§€ìƒ" checked> ì§€ìƒ</label>
    <label><input type="radio" name="floorType" value="ì§€í•˜"> ì§€í•˜</label>
    <input type="number" id="floorNumber" min="1" value="1" style="width:70px"> ì¸µ
  </div>
  <label style="display:block; margin-top:8px;">ë…¸ë“œ ì´ë¦„:
    <input type="text" id="nodeName" placeholder="ì˜ˆ: 1ë²ˆ ê³„ë‹¨ / ì—ìŠ¤1 / ì—˜ë¦¬1" style="width:100%;">
  </label>
  <div style="margin-top:8px;">
    <span>ë…¸ë“œ íƒ€ì…:</span><br>
    <button type="button" class="typeBtn" data-type="normal">normal</button>
    <button type="button" class="typeBtn" data-type="elevator">elevator</button>
    <button type="button" class="typeBtn" data-type="stairs">stairs</button>
    <button type="button" class="typeBtn" data-type="escalator">escalator</button>
  </div>
  <label style="display:block; margin-top:8px;">ì°¸ê³ ì‚¬í•­:
    <input type="text" id="nodeNote" placeholder="ì˜ˆ: ì¶œì…êµ¬/í™”ì¥ì‹¤ ë°©í–¥ ë“±" style="width:100%;">
  </label>
  <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
    <button id="cancelNodeBtn" class="secondary">ì·¨ì†Œ</button>
    <button id="saveNodeBtn">ì €ì¥</button>
  </div>
</div>

<script>
/* ========== ì „ì—­ ìƒíƒœ ========== */
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');

const searchInput = document.getElementById('searchInput');
const infoBox = document.getElementById('infoBox');
const startSel = document.getElementById('start');
const endSel = document.getElementById('end');
const addNodeBtn = document.getElementById('addNodeBtn');
const searchResults = document.getElementById('searchResults');
const routeBtn = document.getElementById('routeBtn');
const resetBtn = document.getElementById('resetBtn');
const downloadBtn = document.getElementById('downloadBtn');

let floorImg = null;
let imgW = 0, imgH = 0;       // ì›ë³¸ ì´ë¯¸ì§€ í¬ê¸° (naturalWidth / naturalHeight)
let scale = 1, offsetX = 0, offsetY = 0; // í™”ë©´ì— ê·¸ë¦´ ë•Œ ì‚¬ìš©ë˜ëŠ” ë³€í™˜
let nodes = {};      // { "ì§€ìƒ1ì¸µ A": {x,y,floor,type,note}, ... }  -> x,y are ORIGINAL image pixels
let edges = {};      // adjacency list
let nodeNames = [];  // order
let blinkNode = null;
let blinkInterval = null;
let pathNodes = [];
let selectingMode = null;
let addingNodeMode = false;
let tempX=0, tempY=0, selectedType='normal';
let password = 'knp123';
let infoTimeout = null;
let lastClickTime = 0;

/* ========== ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì • ========== */
function resizeCanvas(){
  const vh = Math.max(window.innerHeight, document.documentElement.clientHeight || 0);
  const vw = Math.max(window.innerWidth, document.documentElement.clientWidth || 0);
  canvas.width = vw;
  canvas.height = vh;
  computeTransform();
  draw();
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', ()=> setTimeout(resizeCanvas, 200));

/* ========== ì´ë¯¸ì§€ & JSON ìë™ ë¡œë“œ ========== */
function loadFloorImage(){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      floorImg = img;
      imgW = img.naturalWidth;
      imgH = img.naturalHeight;
      computeTransform();
      resolve();
    };
    img.onerror = (e) => reject(new Error('floorplan.png ë¡œë“œ ì‹¤íŒ¨'));
    img.src = 'floorplan.png';
  });
}

function loadLocations(){
  return fetch('locations.json', { cache: 'no-store' })
    .then(res => {
      if(!res.ok) throw new Error('locations.json ë¡œë“œ ì‹¤íŒ¨');
      return res.json();
    })
    .then(data => {
      nodes = data.nodes || {};
      edges = data.edges || {};
      nodeNames = data.nodeNames || Object.keys(nodes);
      nodeNames.forEach(n => { if(!edges[n]) edges[n] = []; });
    })
    .catch(err => {
      console.warn('locations.json ë¡œë“œ ì‹¤íŒ¨:', err);
      nodes = {}; edges = {}; nodeNames = [];
    });
}

/* ========== ì´ˆê¸°í™” ì‹œí€€ìŠ¤ ========== */
(async function init(){
  await Promise.allSettled([loadFloorImage(), loadLocations()]);
  bindUI();
  resizeCanvas();
  draw();
})();

/* ========== ë³€í™˜ ê³„ì‚°: í™”ë©´ <- ì›ë³¸ ì´ë¯¸ì§€ ì¢Œí‘œ ========== */
function computeTransform(){
  if(!floorImg || !imgW || !imgH){ scale = 1; offsetX = 0; offsetY = 0; return; }
  const cw = canvas.width, ch = canvas.height;
  const sx = cw / imgW, sy = ch / imgH;
  // ê· ì¼ ìŠ¤ì¼€ì¼ë¡œ ë¹„ìœ¨ ìœ ì§€ (contain)
  scale = Math.min(sx, sy);
  // ì´ë¯¸ì§€ê°€ ìº”ë²„ìŠ¤ ì¤‘ì•™ì— ìœ„ì¹˜í•˜ë„ë¡ ì˜¤í”„ì…‹ ê³„ì‚°
  const drawW = imgW * scale, drawH = imgH * scale;
  offsetX = Math.max(0, (cw - drawW) / 2);
  offsetY = Math.max(0, (ch - drawH) / 2);
}

/* ì›ë³¸ ì¢Œí‘œ -> í™”ë©´ ì¢Œí‘œ */
function toScreenCoord(origX, origY){
  return { x: offsetX + origX * scale, y: offsetY + origY * scale };
}

/* í™”ë©´ ì¢Œí‘œ -> ì›ë³¸ ì¢Œí‘œ */
function toOriginalCoord(screenX, screenY){
  return { x: (screenX - offsetX) / scale, y: (screenY - offsetY) / scale };
}

/* ========== ìœ í‹¸/ë¼ë²¨ ========== */
function getLabel(fullName){
  const s = fullName.split(' ');
  return s.length > 1 ? s.slice(1).join(' ').trim() : fullName;
}

/* ========== UI ë°”ì¸ë”© ========== */
function bindUI(){
  startSel.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); enterSelectingMode('start'); startSel.blur(); });
  endSel.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); enterSelectingMode('end'); endSel.blur(); });

  routeBtn.addEventListener('click', findPath);
  resetBtn.addEventListener('click', ()=> resetAll(false));
  downloadBtn.addEventListener('click', downloadJSON);
  document.getElementById('searchBtn').addEventListener('click', manualSearch);

  // í„°ì¹˜ ì§€ì›
  canvas.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const x = t.clientX - rect.left, y = t.clientY - rect.top;
    handleCanvasTap(x, y);
  }, { passive:true });

  // ë§ˆìš°ìŠ¤ í´ë¦­
  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    handleCanvasTap(x, y);
  });

  addNodeBtn.addEventListener('click', ()=>{
    const inputPwd = prompt("ë…¸ë“œì¶”ê°€ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
    if(inputPwd === password){
      showInfo('ìº”ë²„ìŠ¤ì—ì„œ ë…¸ë“œë¥¼ ì¶”ê°€í•  ìœ„ì¹˜ë¥¼ íƒ­/í´ë¦­í•˜ì„¸ìš”.', 2000);
      addingNodeMode = true;
    } else {
      alert("ë¹„ë°€ë²ˆí˜¸ í‹€ë¦¼. ë…¸ë“œì¶”ê°€ ì·¨ì†Œ.");
    }
  });

  searchInput.addEventListener('input', ()=>{
    const q = searchInput.value;
    const results = searchNodes(q);
    searchResults.innerHTML = '';
    if(results.length>0){
      searchResults.style.display = 'block';
      results.forEach(r => {
        const div = document.createElement('div');
        div.textContent = r.display;
        div.addEventListener('click', ()=> {
          searchInput.value = getLabel(r.fullName);
          searchResults.style.display='none';
          highlightNode(r.fullName);
        });
        searchResults.appendChild(div);
      });
      // ìœ„ì¹˜ ì¡°ì •: searchResults ë°”ë¡œ ì•„ë˜ì— ë³´ì—¬ì§€ê²Œ
      const rect = document.getElementById('controls').getBoundingClientRect();
      searchResults.style.left = '10px';
      searchResults.style.top = (rect.bottom + 6) + 'px';
    } else {
      searchResults.style.display = 'none';
    }
  });

  document.querySelectorAll('#nodeDialog .typeBtn').forEach(btn => btn.addEventListener('click', ()=> { selectedType = btn.dataset.type; }));
  document.getElementById('cancelNodeBtn').addEventListener('click', closeNodeDialog);
  document.getElementById('saveNodeBtn').addEventListener('click', saveNode);

  // ì£¼ê¸°ì ìœ¼ë¡œ select ì˜µì…˜ ê°±ì‹  (listë¥¼ ìº”ë²„ìŠ¤ì—ì„œë§Œ ì±„ìš°ëŠ” ëŒ€ì‹  í¸ì˜ ì œê³µ)
  setInterval(refreshSelectOptions, 1200);
}

/* ========== ì •ë³´ í† ìŠ¤íŠ¸ ========== */
function showInfo(text, ms=2000, x=null, y=null){
  if(infoTimeout){ clearTimeout(infoTimeout); infoTimeout=null; }
  infoBox.style.display = 'block';
  infoBox.textContent = text;
  if(x!==null && y!==null){
    infoBox.style.left = (x+10) + 'px';
    infoBox.style.top = (y-30) + 'px';
  } else {
    infoBox.style.left = '10px';
    infoBox.style.top = (window.innerHeight - 48) + 'px';
  }
  if(ms>0){
    infoTimeout = setTimeout(()=>{ infoBox.style.display='none'; infoTimeout=null; }, ms);
  }
}

/* ========== ì„ íƒ ëª¨ë“œ ========== */
function enterSelectingMode(mode){
  selectingMode = mode;
  showInfo((mode==='start'?'ì¶œë°œ':'ëª©ì ì§€')+' ë…¸ë“œë¥¼ ìº”ë²„ìŠ¤ì—ì„œ ì„ íƒí•˜ì„¸ìš”.', 1800);
}

/* ========== ìº”ë²„ìŠ¤ íƒ­/í´ë¦­ ì²˜ë¦¬ ========== */
function handleCanvasTap(screenX, screenY){
  if(!floorImg) return;
  const clickedNode = findNodeAt(screenX, screenY);

  // ì„ íƒ ëª¨ë“œ
  if(selectingMode){
    if(clickedNode){
      const sel = (selectingMode==='start') ? startSel : endSel;
      sel.innerHTML = '';
      const opt = document.createElement('option');
      opt.value = clickedNode; opt.textContent = getLabel(clickedNode);
      sel.appendChild(opt);
      sel.value = clickedNode;
      selectingMode = null;
      showInfo('ì„ íƒ ì™„ë£Œ: ' + clickedNode, 1200);
      draw();
      return;
    } else {
      showInfo('ë…¸ë“œë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”.', 1200);
      return;
    }
  }

  // ë…¸ë“œ ì¶”ê°€ ëª¨ë“œ
  if(addingNodeMode){
    const orig = toOriginalCoord(screenX, screenY);
    tempX = orig.x; tempY = orig.y;
    openNodeDialog();
    addingNodeMode = false;
    return;
  }

  if(clickedNode){
    const now = Date.now();
    if(now - lastClickTime < 300){
      const inputPwd = prompt("ë…¸ë“œ ì‚­ì œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
      if(inputPwd === password){
        deleteNode(clickedNode);
        showInfo('ë…¸ë“œ ì‚­ì œ ì™„ë£Œ',1200,screenX,screenY);
        draw();
      } else {
        alert("ë¹„ë°€ë²ˆí˜¸ í‹€ë¦¼. ì‚­ì œ ì·¨ì†Œ.");
      }
    } else {
      const n = nodes[clickedNode];
      showInfo(`${getLabel(clickedNode)} : ${n.note||'ì°¸ê³ ì‚¬í•­ ì—†ìŒ'}`, 2000, screenX, screenY);
    }
    lastClickTime = now;
  }
}

/* ========== ë…¸ë“œ íƒì§€ (í™”ë©´ ì¢Œí‘œ ì…ë ¥) ========== */
function findNodeAt(screenX, screenY){
  for(let name of nodeNames){
    const node = nodes[name];
    if(!node) continue;
    const s = toScreenCoord(node.x, node.y);
    const r = 12; // í„°ì¹˜ ì¹œí™”ì  ë°˜ê²½
    if(Math.hypot(s.x - screenX, s.y - screenY) <= r) return name;
  }
  return null;
}

/* ========== ê·¸ë˜í”„ & Dijkstra ========== */
function distance(n1,n2){ return Math.hypot(n1.x-n2.x, n1.y-n2.y); }
function dijkstra(start,end,allowedNodes=null){
  const visited=new Set(), distances={}, prev={};
  const targetNodes = allowedNodes || nodeNames.slice();
  targetNodes.forEach(n=>{ distances[n]=Infinity; });
  distances[start]=0;

  while(visited.size<targetNodes.length){
    let minNode=null;
    for(let n of targetNodes){
      if(!visited.has(n) && (minNode===null || distances[n] < distances[minNode])) minNode = n;
    }
    if(minNode===null) break;
    if(minNode===end) break;
    visited.add(minNode);

    const adj = edges[minNode] || [];
    for(let nb of adj){
      if(!targetNodes.includes(nb)) continue;
      const alt = distances[minNode] + distance(nodes[minNode], nodes[nb]);
      if(alt < distances[nb]) { distances[nb] = alt; prev[nb] = minNode; }
    }
  }

  const path = []; let cur = end;
  while(cur){ path.unshift(cur); cur = prev[cur]; }
  if(path[0] !== start) return [];
  return path;
}

function multiFloorPath(startName, endName){ return dijkstra(startName, endName); }

function findPath(){
  const s = startSel.value, e = endSel.value;
  if(!s || !e){ alert('ì¶œë°œì§€/ëª©ì ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.'); return; }
  pathNodes = multiFloorPath(s,e) || [];
  if(pathNodes.length === 0) alert('ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
  draw();
}

/* ========== ê²€ìƒ‰ ========== */
function normalize(str){ return String(str||'').replace(/\s+/g,'').replace(/[^\wê°€-í£]/g,'').toLowerCase(); }

function searchNodes(query){
  const q = normalize(query);
  if(q.length < 2) return [];
  const results = [];
  for(let name of nodeNames){
    const node = nodes[name];
    const fields = [name, node.type, node.note||''];
    for(let f of fields){
      if(normalize(f).includes(q)){
        results.push({ fullName: name, display: `${getLabel(name)} [${node.type}] ${node.note||''}` });
        break;
      }
    }
  }
  return results;
}

function manualSearch(){
  const val = searchInput.value.trim();
  if(!val){ alert('ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.'); return; }
  const results = searchNodes(val);
  if(results.length>0) highlightNode(results[0].fullName);
  else alert('ë…¸ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
}

/* ========== ê°•ì¡°(ê¹œë¹¡ì„) ========== */
function highlightNode(name=null){
  const nodeToBlink = name || nodeNames.find(n => getLabel(n) === searchInput.value);
  if(!nodeToBlink){ alert('ë…¸ë“œ ì—†ìŒ'); return; }

  if(blinkInterval) clearInterval(blinkInterval);
  blinkNode = nodeToBlink;

  let opacity = 0.2, growing = true;
  blinkInterval = setInterval(()=>{
    if(growing){ opacity += 0.1; if(opacity >= 0.85) growing = false; }
    else { opacity -= 0.1; if(opacity <= 0.2) growing = true; }
    draw(opacity);
  },100);

  setTimeout(()=>{ clearInterval(blinkInterval); blinkInterval = null; blinkNode = null; draw(); }, 3000);
}

/* ========== ë…¸ë“œ ì¶”ê°€/ì €ì¥/ì‚­ì œ ========== */
function openNodeDialog(){ document.getElementById('nodeDialog').style.display='block'; }
function closeNodeDialog(){ document.getElementById('nodeDialog').style.display='none'; }

function addEdge(a,b){
  edges[a] = edges[a] || []; edges[b] = edges[b] || [];
  if(!edges[a].includes(b)) edges[a].push(b);
  if(!edges[b].includes(a)) edges[b].push(a);
}

function saveNode(){
  const nameField = document.getElementById('nodeName');
  const floor = document.querySelector('input[name="floorType"]:checked').value + document.getElementById('floorNumber').value + 'ì¸µ';
  const name = nameField.value.trim();
  const note = document.getElementById('nodeNote').value.trim();
  if(!name){ alert('ë…¸ë“œ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.'); return; }
  const fullName = `${floor} ${name}`;
  if(nodes[fullName]){ alert('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë…¸ë“œì…ë‹ˆë‹¤.'); return; }

  // tempX,tempY are ORIGINAL coordinates (set when clicking canvas)
  nodes[fullName] = { x: tempX, y: tempY, floor, type: selectedType, note };
  nodeNames.push(fullName);

  // ê°™ì€ ì¸µ ê¸°ë³¸ ì—°ê²°
  nodeNames.forEach(n=>{
    if(n !== fullName && nodes[n].floor === floor) addEdge(n, fullName);
  });

  // ê°™ì€ ì´ë¦„ì˜ elevator/stairs/escalator ì¸µê°„ ì—°ê²°
  if(selectedType === 'elevator' || selectedType === 'stairs' || selectedType === 'escalator'){
    for(let n of nodeNames){
      if(n === fullName) continue;
      if(nodes[n].type === selectedType && getLabel(n) === getLabel(fullName)) addEdge(n, fullName);
    }
  }

  // reset dialog inputs
  nameField.value = '';
  document.getElementById('nodeNote').value = '';
  closeNodeDialog();
  draw();
}

function deleteNode(name){
  delete nodes[name];
  nodeNames = nodeNames.filter(n => n !== name);
  delete edges[name];
  for(let k in edges) edges[k] = edges[k].filter(x => x !== name);
  pathNodes = [];
}

/* ========== JSON ë‹¤ìš´ë¡œë“œ ========== */
function downloadJSON(){
  const data = { nodes, edges, nodeNames };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'locations.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  showInfo('locations.json ë‹¤ìš´ë¡œë“œ ì™„ë£Œ', 1400);
}

/* ========== ì´ˆê¸°í™” ========== */
function resetAll(skipConfirm=false){
  if(!skipConfirm && !confirm('ê²½ë¡œ ë° ê°•ì¡°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
  pathNodes = [];
  if(blinkInterval){ clearInterval(blinkInterval); blinkInterval = null; }
  blinkNode = null;
  selectingMode = null;
  addingNodeMode = false;
  if(infoTimeout){ clearTimeout(infoTimeout); infoTimeout = null; }
  infoBox.style.display = 'none';
  startSel.innerHTML = ''; endSel.innerHTML = '';
  searchResults.style.display = 'none';
  draw();
}

/* ========== ê·¸ë¦¬ê¸° ========== */
function draw(opacity=1){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ë¹„ìœ¨ ìœ ì§€, ì¤‘ì•™ ì •ë ¬)
  if(floorImg){
    computeTransform(); // ìµœì‹ í™”
    ctx.drawImage(floorImg, offsetX, offsetY, imgW * scale, imgH * scale);
  } else {
    // ë°°ê²½ìƒ‰ í‘œì‹œ
    ctx.fillStyle = '#fafafa'; ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // ê²½ë¡œ ê·¸ë¦¬ê¸° (ì›ë³¸ ì¢Œí‘œ -> í™”ë©´ ì¢Œí‘œ ë³€í™˜)
  if(pathNodes.length > 1){
    ctx.strokeStyle = 'red'; ctx.lineWidth = 4; ctx.lineJoin = 'round';
    ctx.beginPath();
    pathNodes.forEach((nm, idx) => {
      const n = nodes[nm]; if(!n) return;
      const s = toScreenCoord(n.x, n.y);
      if(idx === 0) ctx.moveTo(s.x, s.y); else ctx.lineTo(s.x, s.y);
    });
    ctx.stroke();
  }

  // ë…¸ë“œ ê·¸ë¦¬ê¸°
  ctx.font = '12px system-ui';
  ctx.textBaseline = 'middle';
  nodeNames.forEach(nm => {
    const n = nodes[nm]; if(!n) return;
    const s = toScreenCoord(n.x, n.y);
    let radius = 9;
    if(nm === blinkNode) radius = 14;
    ctx.beginPath();
    ctx.arc(s.x, s.y, radius, 0, Math.PI*2);
    if(nm === blinkNode) ctx.fillStyle = `rgba(255,255,0,${opacity})`;
    else if(pathNodes.includes(nm)) ctx.fillStyle = 'red';
    else ctx.fillStyle = (n.type==='normal') ? '#2563eb' : (n.type==='stairs') ? '#f59e0b' : (n.type==='elevator') ? '#16a34a' : '#9333ea';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.stroke();

    // ë¼ë²¨ (í™”ë©´ì— ê²¹ì¹˜ì§€ ì•Šë„ë¡ ì ì ˆ ì˜¤í”„ì…‹)
    ctx.fillStyle = '#000';
    ctx.fillText(getLabel(nm), s.x + radius + 6, s.y);
  });
}

/* ========== í¸ì˜: select ì˜µì…˜ ê°±ì‹  ========== */
function refreshSelectOptions(){
  const fill = (sel) => {
    const cur = sel.value;
    sel.innerHTML = '<option value="">(ìº”ë²„ìŠ¤ì—ì„œ ì„ íƒ)</option>';
    nodeNames.forEach(n => {
      const opt = document.createElement('option'); opt.value = n; opt.textContent = getLabel(n);
      sel.appendChild(opt);
    });
    if(cur && nodeNames.includes(cur)) sel.value = cur;
  };
  fill(startSel); fill(endSel);
}

/* ========== ì£¼ê¸° ê°±ì‹  ========== */
setInterval(refreshSelectOptions, 1200);

</script>
</body>
</html>
