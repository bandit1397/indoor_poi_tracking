<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>🏬 다층 백화점 길안내</title>
<style>
  body { margin:0; font-family:sans-serif; text-align:center; }
  canvas { border:1px solid #ccc; display:block; margin:10px auto; cursor:crosshair; }
  #controls { margin:10px; }
  input, button { padding:6px; margin:5px; font-size:16px; }
</style>
</head>
<body>
<h2>백화점 길안내</h2>
<div id="controls">
  <input type="text" id="searchBox" placeholder="위치 검색">
  <button onclick="searchNode()">검색</button>
  <button onclick="resetPath()">경로 초기화</button>
</div>
<canvas id="mapCanvas" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

let img = new Image();
let nodes = [];
let connections = [];
let selectedStart = null;
let selectedEnd = null;
let highlightNode = null;
let blinkInterval;

// ✅ floorplan.png 자동 로드
img.src = 'floorplan.png';
img.onload = () => draw();

// ✅ locations.json 자동 로드
fetch('locations.json')
  .then(response => response.json())
  .then(data => {
    nodes = data.nodes;
    connections = data.connections;
    draw();
  })
  .catch(err => console.error('JSON 로드 실패:', err));

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const clickedNode = nodes.find(n => Math.hypot(n.x - x, n.y - y) < 10);
  
  if (clickedNode) {
    if (!selectedStart) {
      selectedStart = clickedNode;
    } else if (!selectedEnd && clickedNode !== selectedStart) {
      selectedEnd = clickedNode;
      findPath();
    }
  }
  draw();
});

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (img.complete) {
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  }
  ctx.fillStyle = 'blue';
  nodes.forEach(n => {
    ctx.beginPath();
    ctx.arc(n.x, n.y, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillText(n.name, n.x + 10, n.y);
  });
  
  if (selectedStart) {
    ctx.fillStyle = 'green';
    ctx.beginPath();
    ctx.arc(selectedStart.x, selectedStart.y, 10, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if (selectedEnd) {
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(selectedEnd.x, selectedEnd.y, 10, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if (highlightNode) {
    ctx.fillStyle = 'yellow';
    ctx.beginPath();
    ctx.arc(highlightNode.x, highlightNode.y, 12, 0, Math.PI * 2);
    ctx.fill();
  }
}

function findPath() {
  const queue = [selectedStart];
  const visited = new Set([selectedStart.name]);
  const parent = {};
  
  while (queue.length > 0) {
    const current = queue.shift();
    if (current === selectedEnd) break;
    const neighbors = connections
      .filter(c => c.from === current.name || c.to === current.name)
      .map(c => nodes.find(n => n.name === (c.from === current.name ? c.to : c.from)));
    
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor.name)) {
        visited.add(neighbor.name);
        parent[neighbor.name] = current.name;
        queue.push(neighbor);
      }
    }
  }
  
  let path = [];
  let node = selectedEnd.name;
  while (node && node !== selectedStart.name) {
    path.push(node);
    node = parent[node];
  }
  path.push(selectedStart.name);
  path.reverse();
  
  ctx.strokeStyle = 'orange';
  ctx.lineWidth = 4;
  ctx.beginPath();
  const startNode = nodes.find(n => n.name === path[0]);
  ctx.moveTo(startNode.x, startNode.y);
  for (let i = 1; i < path.length; i++) {
    const nextNode = nodes.find(n => n.name === path[i]);
    ctx.lineTo(nextNode.x, nextNode.y);
  }
  ctx.stroke();
}

function searchNode() {
  const query = document.getElementById('searchBox').value.trim();
  const node = nodes.find(n => n.name.includes(query));
  if (node) {
    highlightNode = node;
    if (blinkInterval) clearInterval(blinkInterval);
    blinkInterval = setInterval(() => {
      highlightNode = highlightNode ? null : node;
      draw();
    }, 500);
  } else {
    alert('해당 위치를 찾을 수 없습니다.');
  }
}

function resetPath() {
  selectedStart = null;
  selectedEnd = null;
  highlightNode = null;
  if (blinkInterval) clearInterval(blinkInterval);
  draw();
}
</script>
</body>
</html>
