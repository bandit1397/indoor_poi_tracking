<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>ğŸ¬ ë‹¤ì¸µ ë°±í™”ì  ê¸¸ì•ˆë‚´ (ìˆ˜ì •ë³¸) â€” ìƒëŒ€ì¢Œí‘œ ì§€ì›</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<style>
  :root { color-scheme: light dark; }
  * { box-sizing: border-box; }
  body { margin:0; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  canvas { border:1px solid #ccc; display:block; cursor:crosshair; }
  /* Controls */
  #controls {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%); /* ì¤‘ì•™ ì •ë ¬ */
    background: rgba(255,255,255,0.95);
    padding: 10px;
    border-radius: 10px;
    z-index: 10;
    box-shadow: 0 4px 16px rgba(0,0,0,0.15);
    backdrop-filter: saturate(1.2) blur(4px);
    max-width: calc(100vw - 20px);
    transition: width 220ms ease, height 220ms ease, padding 220ms ease;
}

  #controls .row { display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; align-items:center; }
  select, button, input { margin:0; padding:8px 10px; border-radius:8px; border:1px solid #ddd; font-size:14px; }
  button { background:#0ea5e9; color:white; border:none; cursor:pointer; }
  button.secondary { background:#64748b; }
  button.warn { background:#ef4444; }
  button:active { transform: translateY(1px); }
  #infoBox {
    position: absolute;
    background: rgba(0,0,0,0.7); color:#fff; padding:6px 10px; border-radius:8px; font-weight:600;
    display:none; pointer-events:none; white-space: nowrap; z-index: 9;
  }
  #nodeDialog {
    display:none; position:fixed; top:50%; left:50%;
    transform:translate(-50%,-50%);
    background:#fff; border:1px solid #e5e7eb; padding:16px;
    border-radius:12px; z-index:1000; box-shadow:0 12px 30px rgba(0,0,0,0.25); width:min(92vw,420px);
  }
  #nodeDialog h3 { margin:0 0 10px 0; font-size:18px; }
  /* ğŸ”½ ë…¸ë“œ íƒ€ì… ë²„íŠ¼ ì»¬ëŸ¬ & ìŠ¤íƒ€ì¼ (ì¶”ê°€) */
  #nodeDialog .typeBtn {
    margin:4px;
    padding:6px 12px;
    cursor:pointer;
    border-radius:999px;
    font-weight:600;
    border:1px solid transparent;
    transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
  }

  #nodeDialog .typeBtn[data-type="normal"] {
    background:#2563eb;
    color:#fff;
  }

  #nodeDialog .typeBtn[data-type="elevator"] {
    background:#16a34a;
    color:#fff;
  }

  #nodeDialog .typeBtn[data-type="stairs"] {
    background:#f59e0b;
    color:#fff;
  }

  #nodeDialog .typeBtn[data-type="escalator"] {
    background:#9333ea;
    color:#fff;
  }

  #nodeDialog .typeBtn.active {
    box-shadow: 0 0 0 3px rgba(0,0,0,0.25);
  }

  #nodeDialog .typeBtn:active {
    transform: translateY(1px);
    opacity: 0.9;
  }

  #nodeDialog label { display:block; margin-top:8px; }
  #searchResults {
    position:absolute; background:#fff; border:1px solid #e5e7eb; border-radius:8px;
    display:none; z-index:10; max-height:220px; overflow-y:auto; min-width: 240px; box-shadow: 0 8px 24px rgba(0,0,0,0.12);
  }
  #searchResults div { padding:6px 8px; cursor:pointer; }
  #searchResults div:hover { background:#eef; }

  /* Toggle (small hamburger) button inside controls */
  #toggleControlsBtn { display:inline-flex; align-items:center; justify-content:center; width:40px; height:40px; padding:0; font-size:18px; background:transparent; color:#0f172a; border-radius:8px; border:1px solid transparent; cursor:pointer; }
  #toggleControlsBtn:focus { outline:2px solid #cbd5e1; }

  /* Collapsed style: hide most rows visually but keep DOM intact (functionality preserved) */
  #controls.collapsed { width:56px; height:56px; padding:6px; overflow:visible; }
  #controls.collapsed strong { display:none; }
  #controls.collapsed .row { margin-top:4px; }
  /* hide all */
  #controls.collapsed .row:not(.toggleRow) {
   display: none;
  }
  
  @media (max-width: 640px) {
    #controls {
        left: 50%;
        transform: translateX(-50%);
    }
    select, input { min-width: 140px; }
}

</style>
</head>
<body>

<div id="controls" role="region" aria-label="ê¸¸ì•ˆë‚´ ì»¨íŠ¸ë¡¤">

  <!-- 1ï¸âƒ£ â˜° ë²„íŠ¼ ì „ìš© row -->
  <div class="row toggleRow">
    <button id="toggleControlsBtn" aria-expanded="true" title="ì»¨íŠ¸ë¡¤ ì ‘ê¸°/í¼ì¹˜ê¸°">â˜°</button>
  </div>

  <!-- 2ï¸âƒ£ ì¸µê°„ ê¸¸ì•ˆë‚´ + ë‹¤ìš´ë¡œë“œ/ì´ˆê¸°í™” ë²„íŠ¼ -->
  <div class="row">
    <strong>ì¸µê°„ ê¸¸ì•ˆë‚´</strong>
    <button id="downloadBtn" class="secondary" title="í˜„ì¬ ë…¸ë“œ ë°ì´í„°ë¥¼ JSONìœ¼ë¡œ ì €ì¥">JSON ë‹¤ìš´ë¡œë“œ</button>
    <button id="resetBtn" class="warn" title="ê²½ë¡œ ë° ìƒíƒœ ì´ˆê¸°í™”">ì´ˆê¸°í™”</button>
    <button id="stopBlinkBtn" class="secondary" title="ê°•ì¡° í•´ì œ">ê¹œë¹¡ì„ í•´ì œ</button>
  </div>

  <!-- 3ï¸âƒ£ ì¶œë°œì§€/ëª©ì ì§€/ê¸¸ì°¾ê¸° -->
  <div class="row">
    ì¶œë°œì§€: <select id="start" title="ì¶œë°œì§€ ì„ íƒ(ìº”ë²„ìŠ¤ì—ì„œ ë…¸ë“œë¥¼ í´ë¦­í•´ë„ ë©ë‹ˆë‹¤)"></select>
    ëª©ì ì§€: <select id="end" title="ëª©ì ì§€ ì„ íƒ(ìº”ë²„ìŠ¤ì—ì„œ ë…¸ë“œë¥¼ í´ë¦­í•´ë„ ë©ë‹ˆë‹¤)"></select>
    <button id="routeBtn" title="ìµœë‹¨ ê²½ë¡œ ì°¾ê¸°">ê¸¸ì°¾ê¸°</button>
  </div>

  <!-- 4ï¸âƒ£ ìœ„ì¹˜ ê²€ìƒ‰ / ë…¸ë“œì¶”ê°€ -->
  <div class="row" style="position:relative;">
    ìœ„ì¹˜ ê²€ìƒ‰: <input type="text" id="searchInput" autocomplete="off" placeholder="ì˜ˆ: 1ë²ˆ ê³„ë‹¨ / í‘¸ë“œì½”íŠ¸">
    <button id="searchBtn">ê²€ìƒ‰</button>
    <button id="addNodeBtn">ë…¸ë“œì¶”ê°€</button>
    <div id="searchResults" role="listbox" aria-label="ê²€ìƒ‰ ê²°ê³¼"></div>
  </div>

</div>

<div id="infoBox"></div>
<canvas id="map" aria-label="ì¸µê°„ ì§€ë„ ìº”ë²„ìŠ¤"></canvas>

<!-- ë…¸ë“œ ì…ë ¥ ë‹¤ì´ì–¼ë¡œê·¸ -->
<div id="nodeDialog" role="dialog" aria-modal="true" aria-labelledby="nodeDialogTitle">
  <h3 id="nodeDialogTitle">ìƒˆ ë…¸ë“œ ì¶”ê°€</h3>
  <div>
    <label>
      <input type="radio" name="floorType" value="ì§€ìƒ" checked> ì§€ìƒ
    </label>
    <label>
      <input type="radio" name="floorType" value="ì§€í•˜"> ì§€í•˜
    </label>
    <label>
      ì¸µ/êµ¬ì—­:
      <select id="floorNumber">
        <option>1ì¸µ 1êµ¬ì—­</option>
        <option>1ì¸µ 2êµ¬ì—­</option>
        <option>1ì¸µ 3êµ¬ì—­</option>
        <option>2ì¸µ 1êµ¬ì—­</option>
        <option>2ì¸µ 2êµ¬ì—­</option>
        <option>2ì¸µ 3êµ¬ì—­</option>
        <option>3ì¸µ 1êµ¬ì—­</option>
        <option>3ì¸µ 2êµ¬ì—­</option>
        <option>3ì¸µ 3êµ¬ì—­</option>
        <!-- í•„ìš”ì— ë”°ë¼ í™•ì¥ -->
      </select>
    </label>
  </div>
  <label>ë…¸ë“œ ì´ë¦„:
    <input type="text" id="nodeName" placeholder="ì˜ˆ: 1ë²ˆ ê³„ë‹¨ / ì—ìŠ¤1 / ì—˜ë¦¬1">
  </label>
  <div style="margin-top:8px;">
    <span>ë…¸ë“œ íƒ€ì…:</span><br>
    <button type="button" class="typeBtn" data-type="normal">normal</button>
    <button type="button" class="typeBtn" data-type="elevator">elevator</button>
    <button type="button" class="typeBtn" data-type="stairs">stairs</button>
    <button type="button" class="typeBtn" data-type="escalator">escalator</button>
  </div>
  <label>ì°¸ê³ ì‚¬í•­:
    <input type="text" id="nodeNote" placeholder="ì˜ˆ: ì¶œì…êµ¬/í™”ì¥ì‹¤ ë°©í–¥ ë“±">
  </label>
  <div style="margin-top:12px; display:flex; gap:8px; justify-content:flex-end;">
    <button id="cancelNodeBtn" class="secondary">ì·¨ì†Œ</button>
    <button id="saveNodeBtn">ì €ì¥</button>
  </div>
</div>

<script>
/** ===== ì „ì—­ ìƒíƒœ ===== */
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');

const searchInput = document.getElementById('searchInput');
const infoBox = document.getElementById('infoBox');
const startSel = document.getElementById('start');
const endSel = document.getElementById('end');
const addNodeBtn = document.getElementById('addNodeBtn');
const searchResults = document.getElementById('searchResults');
const routeBtn = document.getElementById('routeBtn');
const resetBtn = document.getElementById('resetBtn');
const downloadBtn = document.getElementById('downloadBtn');
const toggleBtn = document.getElementById('toggleControlsBtn');
const controls = document.getElementById('controls');

let floorImg = null;
let nodes = {};      // nodes should store normalized coords x,y in 0..1 if possible
let edges = {};      
let nodeNames = [];  
let blinkNode = null;
let blinkInterval = null;
let blinkPersistent = false;
let pathNodes = [];

let selectingMode = null;        // ìº”ë²„ìŠ¤ì—ì„œ ì¶œë°œ/ë„ì°© ì„ íƒ
let selectDropdownOpen = null;   // ì¶œë°œ/ë„ì°© select í¼ì¹¨ ìƒíƒœ
let addingNodeMode = false;

let tempX = 0, tempY = 0;
let selectedType = 'normal';

let password = 'knp123';

// helper: compatibility flags
let imageLoaded = false;

/** ===== ë°˜ì‘í˜• ìº”ë²„ìŠ¤ ===== */
function resizeCanvas(){
  const vh = Math.max(window.innerHeight, document.documentElement.clientHeight || 0);
  const vw = Math.max(window.innerWidth, document.documentElement.clientWidth || 0);
  canvas.width = vw;
  canvas.height = vh;
  draw();
}
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 300));

/** ===== ì´ë¯¸ì§€/JSON ìë™ ë¡œë“œ ===== */
function loadFloorImage(){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => { floorImg = img; imageLoaded = true; resolve(); };
    img.onerror = reject;
    img.src = 'floorplan.png'; // ê°™ì€ í´ë”ì— ë°°ì¹˜
  });
}

function loadLocations(){
  return fetch('locations.json', { cache: 'no-store' })
    .then(res => {
      if(!res.ok) throw new Error('locations.json ë¡œë“œ ì‹¤íŒ¨: ' + res.status);
      return res.json();
    })
    .then(data => {
      nodes = data.nodes || {};
      edges = data.edges || {};
      nodeNames = data.nodeNames || Object.keys(nodes);
      // ensure edges keys exist
      nodeNames.forEach(n => { edges[n] = edges[n] || []; });

      // --- IMPORTANT FIX: ensure every node has an explicit 'label' property (the user-provided name)
      // This makes type-based inter-floor linking reliable even when floor strings contain spaces.
      nodeNames.forEach(n => {
        if(!nodes[n].label){
          // if node object contains floor, we can strip that prefix to recover label
          if(nodes[n].floor){
            const prefix = nodes[n].floor + ' ';
            if(n.startsWith(prefix)) nodes[n].label = n.slice(prefix.length);
            else nodes[n].label = n; // fallback
          } else {
            // fallback: take the last token
            const parts = n.split(' ');
            nodes[n].label = parts.slice(-1)[0] || n;
          }
        }
      });

    })
    .catch(err => {
      console.warn(err);
      nodes = {};
      edges = {};
      nodeNames = [];
    });
}

/** ===== ì´ˆê¸°í™” ì‹œí€€ìŠ¤ ===== */
(async function init(){
  await Promise.allSettled([loadFloorImage(), loadLocations()]);
  bindUI();
  resizeCanvas();
  draw();
  // â˜° ë²„íŠ¼ë§Œ ë³´ì´ë„ë¡ ì´ˆê¸° ìƒíƒœì—ì„œ collapsed ì ìš©
  controls.classList.add('collapsed');
})();

/** ===== ë¼ë²¨ ë„ìš°ë¯¸ ===== */
function getLabel(fullName){
  // Prefer explicit stored label for robustness. If missing, fall back to original behaviour.
  if(nodes[fullName] && nodes[fullName].label) return nodes[fullName].label;
  const s = fullName.split(' ');
  return s.length > 1 ? s.slice(1).join(' ').trim() : fullName;
}

/** ===== UI ë°”ì¸ë”© ===== */
function bindUI(){
  startSel.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); enterSelectingMode('start'); startSel.blur(); });
  endSel.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); enterSelectingMode('end'); endSel.blur(); });

  routeBtn.addEventListener('click', findPath);
  resetBtn.addEventListener('click', ()=> resetAll(false));
  downloadBtn.addEventListener('click', downloadJSON);
  document.getElementById('searchBtn').addEventListener('click', manualSearch);

  canvas.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const x = t.clientX - rect.left;
    const y = t.clientY - rect.top;
    handleCanvasTap(x,y);
  }, {passive:true});

  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    handleCanvasTap(e.clientX - rect.left, e.clientY - rect.top);
  });

  addNodeBtn.addEventListener('click',()=>{
    const inputPwd = prompt("ë…¸ë“œì¶”ê°€ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
    if(inputPwd === password){
      showInfo('ìº”ë²„ìŠ¤ì—ì„œ ë…¸ë“œë¥¼ ì¶”ê°€í•  ìœ„ì¹˜ë¥¼ íƒ­/í´ë¦­í•˜ì„¸ìš”.', 2000);
      addingNodeMode = true;
    } else {
      alert("ë¹„ë°€ë²ˆí˜¸ í‹€ë¦¼. ë…¸ë“œì¶”ê°€ ì·¨ì†Œ.");
    }
  });

  searchInput.addEventListener('input', ()=>{
    const query = searchInput.value;
    const results = searchNodes(query);
    searchResults.innerHTML='';
    if(results.length>0){
      searchResults.style.display='block';
      results.forEach(r=>{
        const div = document.createElement('div');
        div.textContent = r.display;
        div.addEventListener('click', ()=>{
          searchInput.value = getLabel(r.fullName);
          searchResults.style.display='none';
          highlightNode(r.fullName);
        });
        searchResults.appendChild(div);
      });
    } else {
      searchResults.style.display='none';
    }
  });

  document.querySelectorAll('#nodeDialog .typeBtn').forEach(btn =>
    btn.addEventListener('click',()=>{
      selectedType = btn.dataset.type;
      document.querySelectorAll('#nodeDialog .typeBtn')
        .forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    })
  );

  document.getElementById('cancelNodeBtn').addEventListener('click', closeNodeDialog);
  document.getElementById('saveNodeBtn').addEventListener('click', saveNode);

  // Toggle controls collapse/expand
  toggleBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    const isCollapsed = controls.classList.toggle('collapsed');
    toggleBtn.setAttribute('aria-expanded', String(!isCollapsed));
    // update tooltip/title
    toggleBtn.title = isCollapsed ? 'ì»¨íŠ¸ë¡¤ í¼ì¹˜ê¸°' : 'ì»¨íŠ¸ë¡¤ ì ‘ê¸°';
  });

  document.getElementById('stopBlinkBtn').addEventListener('click', stopBlink);

  // close search results when clicking elsewhere
  document.addEventListener('click', (e)=>{
    if(!controls.contains(e.target)) searchResults.style.display='none';
  });
}

/** ===== ì •ë³´ í† ìŠ¤íŠ¸ ===== */
let infoTimeout = null;
function showInfo(text, ms=2000, x=null, y=null){
  if(infoTimeout){ clearTimeout(infoTimeout); infoTimeout=null; }
  infoBox.style.display='block';
  infoBox.textContent = text;
  if(x!==null && y!==null){
    infoBox.style.left = (x+10) + 'px';
    infoBox.style.top = (y-30) + 'px';
  } else {
    infoBox.style.left = '10px';
    infoBox.style.top = (window.innerHeight-48)+'px';
  }
  if(ms>0){
    infoTimeout = setTimeout(()=>{ infoBox.style.display='none'; infoTimeout=null; }, ms);
  }
}

/** ===== ì„ íƒ ëª¨ë“œ ===== */
function enterSelectingMode(mode){
  selectingMode = mode;
  showInfo((mode==='start'?'ì¶œë°œ':'ëª©ì ì§€')+' ë…¸ë“œë¥¼ ìº”ë²„ìŠ¤ì—ì„œ ì„ íƒí•˜ì„¸ìš”.', 1800);
}

/** ===== ì¢Œí‘œ ë³€í™˜ ìœ í‹¸ ===== */
function getNodeDisplayCoords(name){
  const n = nodes[name];
  if(!n) return null;
  const hasNorm = (typeof n.x === 'number' && typeof n.y === 'number' && n.x<=1 && n.y<=1);
  if(hasNorm){
    return { x: n.x * canvas.width, y: n.y * canvas.height };
  }
  if(imageLoaded && floorImg && floorImg.width && floorImg.height){
    return { x: (n.x / floorImg.width) * canvas.width, y: (n.y / floorImg.height) * canvas.height };
  }
  return { x: n.x, y: n.y };
}

function getNodeNormalizedCoordsFromCanvas(px,py){
  return { x: px / canvas.width, y: py / canvas.height };

}

/** ===== ìº”ë²„ìŠ¤ íƒ­/í´ë¦­ í•¸ë“¤ëŸ¬ ===== */
let lastClickTime = 0;
function handleCanvasTap(x,y){
  if(!floorImg) return;
  const clickedNode = findNodeAt(x,y);

  if(selectingMode){
    if(clickedNode){
      const sel = (selectingMode==='start') ? startSel : endSel;
      sel.innerHTML='';
      const opt = document.createElement('option');
      opt.value = clickedNode; opt.textContent = getLabel(clickedNode);
      sel.appendChild(opt);
      sel.value = clickedNode;
      selectingMode = null;
      showInfo('ì„ íƒ ì™„ë£Œ: ' + clickedNode, 1200);
      draw();
      return;
    } else {
      showInfo('ë…¸ë“œë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”.', 1200);
      return;
    }
  }

  if(addingNodeMode){
    tempX = x; tempY = y;
    openNodeDialog();
    addingNodeMode = false;
    return;
  }

  if(clickedNode){
    const now = Date.now();
    if(now - lastClickTime < 300){
      const inputPwd = prompt("ë…¸ë“œ ì‚­ì œ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
      if(inputPwd === password){
        deleteNode(clickedNode);
        showInfo('ë…¸ë“œ ì‚­ì œ ì™„ë£Œ',1200,x,y);
        draw();
      } else {
        alert("ë¹„ë°€ë²ˆí˜¸ í‹€ë¦¼. ì‚­ì œ ì·¨ì†Œ.");
      }
    } else {
      const n = nodes[clickedNode];
      showInfo(`${getLabel(clickedNode)} : ${n.note||'ì°¸ê³ ì‚¬í•­ ì—†ìŒ'}`, 2000, x, y);
    }
    lastClickTime = now;
  }
}

/** ===== ìœ í‹¸ ===== */
function findNodeAt(x,y){
  for(let name of nodeNames){
    const d = getNodeDisplayCoords(name);
    if(!d) continue;
    if(Math.hypot(d.x-x,d.y-y)<=12) return name;
  }
  return null;
}

/** ===== ê·¸ë˜í”„ ì—°ì‚°: Dijkstra (display coords used for distance calc) ===== */
function distanceByDisplay(aName,bName){
  const a = getNodeDisplayCoords(aName);
  const b = getNodeDisplayCoords(bName);
  if(!a || !b) return Infinity;
  return Math.hypot(a.x-b.x,a.y-b.y);
}

function dijkstra(start,end,allowedNodes=null){
  const visited=new Set(), distances={}, prev={};
  const targetNodes = allowedNodes || nodeNames.slice();
  targetNodes.forEach(n=>{ distances[n]=Infinity; });
  distances[start]=0;

  while(visited.size<targetNodes.length){
    let minNode=null;
    for(let n of targetNodes){
      if(!visited.has(n)&&(minNode===null||distances[n]<distances[minNode])) minNode=n;
    }
    if(minNode===null) break;
    if(minNode===end) break;
    visited.add(minNode);

    const adj = edges[minNode]||[];
    for(let nb of adj){
      if(!targetNodes.includes(nb)) continue;
      const alt = distances[minNode]+distanceByDisplay(minNode,nb);
      if(alt<distances[nb]) { distances[nb]=alt; prev[nb]=minNode; }
    }
  }

  const path=[]; let curr=end;
  while(curr){ path.unshift(curr); curr=prev[curr]; }
  if(path[0]!==start) return [];
  return path;
}

function multiFloorPath(startName,endName){
  return dijkstra(startName,endName);
}

function findPath(){
  const s = startSel.value; const e = endSel.value;
  if(!s || !e){ alert('ì¶œë°œì§€/ëª©ì ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.'); return; }
  pathNodes = multiFloorPath(s,e) || [];
  if(pathNodes.length===0) alert('ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
  draw();
}

/** ===== ê²€ìƒ‰ ===== */
function normalize(str){
  return String(str||'').replace(/\s+/g,'').replace(/[^\wê°€-í£]/g,'').toLowerCase();
}

function searchNodes(query){
  const q = normalize(query);
  if(q.length<2) return [];
  const results=[];
  for(let name of nodeNames){
    const node = nodes[name];
    const fields = [name, node.type, node.note||'', node.label||''];
    for(let f of fields){
      if(normalize(f).includes(q)){
        results.push({fullName:name, display:`${getLabel(name)} [${node.type}] ${node.note||''}`});
        break;
      }
    }
  }
  return results;
}

function manualSearch(){
  const val = searchInput.value.trim();
  if(!val){ alert('ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.'); return; }
  const results = searchNodes(val);
  if(results.length>0) highlightNode(results[0].fullName);
  else alert('ë…¸ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
}

/** ===== ê¹œë¹¡ì„ ê°•ì¡° ===== */
function highlightNode(name=null){
  const nodeToBlink = name || nodeNames.find(n=>getLabel(n)===searchInput.value);
  if(!nodeToBlink){ alert("ë…¸ë“œ ì—†ìŒ"); return; }

  if(blinkInterval) clearInterval(blinkInterval);
  blinkNode = nodeToBlink;
  blinkPersistent = true; // ì´ì œ ê³„ì† ê¹œë¹¡ì„

  let opacity = 0.2;
  let growing = true;

  blinkInterval = setInterval(()=>{
    if(growing){ opacity += 0.1; if(opacity >= 0.85) growing = false; } 
    else { opacity -= 0.1; if(opacity <= 0.2) growing = true; }
    draw(opacity);
  }, 100);
}

function stopBlink(){
  if(blinkInterval){
    clearInterval(blinkInterval);
    blinkInterval = null;
  }
  blinkNode = null;
  blinkPersistent = false;
  draw();
}



/** ===== ì´ˆê¸°í™” ===== */
function resetAll(skipConfirm=false){
  if(!skipConfirm && !confirm("ê²½ë¡œ ë° ê°•ì¡°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
  pathNodes=[];
  if(blinkInterval){ clearInterval(blinkInterval); blinkInterval=null; }
  blinkNode=null;
  selectingMode = null;
  addingNodeMode = false;
  if(infoTimeout){ clearTimeout(infoTimeout); infoTimeout=null; }
  infoBox.style.display='none';
  startSel.innerHTML=''; endSel.innerHTML='';
  searchResults.style.display='none';
  draw();
}

/** ===== ë…¸ë“œ ë‹¤ì´ì–¼ë¡œê·¸ ===== */
function openNodeDialog(){ document.getElementById('nodeDialog').style.display='block'; }
function closeNodeDialog(){ document.getElementById('nodeDialog').style.display='none'; }

function addEdge(a,b){
  edges[a]=edges[a]||[]; edges[b]=edges[b]||[];
  if(!edges[a].includes(b)) edges[a].push(b);
  if(!edges[b].includes(a)) edges[b].push(a);
}

function saveNode(){
  const name = document.getElementById('nodeName').value.trim();
  const floorType = document.querySelector('input[name="floorType"]:checked').value;
  const floor = floorType + ' ' + document.getElementById('floorNumber').value; // ì„ íƒëœ êµ¬ì—­ í¬í•¨
  const note = document.getElementById('nodeNote').value;
  
  if(!name){ alert("ë…¸ë“œ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”."); return; }
  const fullName = `${floor} ${name}`;
  if(nodes[fullName]){ alert("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë…¸ë“œì…ë‹ˆë‹¤."); return; }

  // ìº”ë²„ìŠ¤ ì¢Œí‘œë¥¼ ì •ê·œí™”
  const norm = getNodeNormalizedCoordsFromCanvas(tempX, tempY);
  // store label (the pure node name) explicitly â€” this is the key fix for robust inter-floor matching
  nodes[fullName] = { x: Number(norm.x.toFixed(6)), y: Number(norm.y.toFixed(6)), floor, type:selectedType, note, label: name };
  nodeNames.push(fullName);

  // ê°™ì€ ì¸µ(êµ¬ì—­ ë‹¨ìœ„) ìë™ ì—°ê²° (unchanged behaviour)
  nodeNames.forEach(n => {
    if(n!==fullName && nodes[n].floor===floor){
      addEdge(n, fullName);
    }
  });

  // íƒ€ì…ë³„ ì¸µê°„ ì—°ê²° â€” now uses explicit 'label' property to compare node identity across floors
  if(selectedType==='escalator' || selectedType==='stairs' || selectedType==='elevator'){
    for(let n of nodeNames){
      if(n===fullName) continue;
      if(nodes[n].type===selectedType && (nodes[n].label||getLabel(n)) === name){
        addEdge(n, fullName);
      }
    }
  }

  closeNodeDialog(); draw();
  draw();
  document.getElementById('nodeName').value='';
  document.getElementById('nodeNote').value='';
  showNodeJson(fullName);  
}

function deleteNode(name){
  delete nodes[name];
  nodeNames = nodeNames.filter(nm=>nm!==name);
  delete edges[name];
  for(let key in edges){ edges[key]=edges[key].filter(nm=>nm!==name); }
  pathNodes=[];
}

/** ===== JSON ë‹¤ìš´ë¡œë“œ ===== */
function downloadJSON(){
  const data = { nodes, edges, nodeNames };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);

  const a = document.createElement('a');
  a.href = url;
  a.download = 'locations.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  showInfo('locations.json ë‹¤ìš´ë¡œë“œ ì™„ë£Œ', 1400);
}

/** ===== ê·¸ë¦¬ê¸° ===== */
function draw(opacity=1){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(floorImg){
    ctx.drawImage(floorImg,0,0,canvas.width,canvas.height);
  }

  // ê²½ë¡œ
  if(pathNodes.length>1){
    ctx.strokeStyle='red'; ctx.lineWidth=4; ctx.lineJoin='round';
    ctx.beginPath();
    pathNodes.forEach((n,i)=>{
      const d = getNodeDisplayCoords(n);
      if(!d) return;
      if(i===0) ctx.moveTo(d.x,d.y);
      else ctx.lineTo(d.x,d.y);
    });
    ctx.stroke();
  }

  // ë…¸ë“œ
  ctx.font = '12px system-ui';
  ctx.textBaseline = 'middle';
  nodeNames.forEach(n=>{
    const node=nodes[n]; if(!node) return;
    const d = getNodeDisplayCoords(n);
    if(!d) return;
    let radius = 9;
    if(n===blinkNode) radius = 9 * 2; // 18px
    ctx.beginPath();
    ctx.arc(d.x,d.y,radius,0,Math.PI*2);
    if(n===blinkNode){ ctx.fillStyle=`rgba(255,0,0,${opacity})`; }
    else if(pathNodes.includes(n)){ ctx.fillStyle='red'; }
    else {
      ctx.fillStyle = (node.type==='normal') ? '#2563eb'
                    : (node.type==='stairs') ? '#f59e0b'
                    : (node.type==='elevator') ? '#16a34a'
                    : '#9333ea';
    }
    ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.stroke();

    // ë¼ë²¨
    ctx.fillStyle='black';
    ctx.fillText(getLabel(n), d.x + radius + 6, d.y);
  });
}

/** ===== ì ‘ê·¼ì„± ë³´ì™„: ì…€ë ‰íŠ¸ ì§ì ‘ ì„ íƒ ì§€ì›(ì˜µì…˜ ëª©ë¡ ì±„ìš°ê¸°) ===== */
function refreshSelectOptions(){
  const makeOptions = (sel) => {
    const curr = sel.value;
    sel.innerHTML = '<option value="">(ìº”ë²„ìŠ¤ì—ì„œ ì„ íƒ ê°€ëŠ¥)</option>';
    nodeNames.forEach(n=>{
      const opt = document.createElement('option');
      opt.value = n; opt.textContent = getLabel(n);
      sel.appendChild(opt);
    });
    if(curr && nodeNames.includes(curr)) sel.value = curr;
  };
  makeOptions(startSel);
  makeOptions(endSel);
}
setInterval(refreshSelectOptions, 1500);

function showNodeJson(fullName){
  const obj = {};
  obj[fullName] = nodes[fullName];

  const text = JSON.stringify(obj, null, 2)
    .replace(/^{\n/, '')
    .replace(/\n}$/, '');

  const panel = document.getElementById('nodeJsonPanel');
  const ta = document.getElementById('nodeJsonOutput');
  ta.value = text;
  panel.style.display = 'block';
  ta.select();
}

function copyNodeJson(){
  const ta = document.getElementById('nodeJsonOutput');
  ta.select();
  document.execCommand('copy');
  alert('JSON ë³µì‚¬ ì™„ë£Œ â†’ locations.jsonì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”');
}

function closeNodeJson(){
  document.getElementById('nodeJsonPanel').style.display = 'none';
}

</script>
<!-- ğŸ”½ ë…¸ë“œ JSON ì¶œë ¥ íŒ¨ë„ -->
<div id="nodeJsonPanel" style="
  position:fixed;
  bottom:10px;
  right:10px;
  width:min(92vw,420px);
  background:#fff;
  border:1px solid #e5e7eb;
  border-radius:10px;
  padding:10px;
  box-shadow:0 8px 24px rgba(0,0,0,.2);
  display:none;
  z-index:2000;
">
  <strong>ğŸ“Œ ìƒˆ ë…¸ë“œ JSON</strong>
  <textarea id="nodeJsonOutput"
    style="width:100%;height:160px;margin-top:6px;font-family:monospace;font-size:12px;"
    readonly></textarea>
  <div style="text-align:right;margin-top:6px;">
    <button onclick="copyNodeJson()" class="secondary">ë³µì‚¬</button>
    <button onclick="closeNodeJson()" class="warn">ë‹«ê¸°</button>
  </div>
</div>

</body>
</html>
